<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--<title>BTC Chart - Lightweight Version</title>-->
    <script src="https://unpkg.com/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js" async></script>
    <style>
        /* body{
            background-color: #121212;
            color: #ffffff;
        } */
        #chart-container {
            width: 100%;
            height: 650px;
            position: relative;
            /*background-color: #1e1e1e;*/
            /*margin-bottom: 20px;*/
        }
        button {
            margin-top: 10px;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            color:#094d91;
        }
        #chart-label {
            font-size: 20px;
            font-weight: bold;
            margin-top: 10px;
        }
        #smaLegend {
            position: absolute;
            right: 20px;
            top: 50px;
            width: 100px;
            
            padding: 10px;
            background: white;
            border-radius: 5px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2); 
            text-align: left;
        }
        .axis-label {
            position: absolute;
            font-size: 14px;
            font-weight: bold;
            color: #000;
        }

        #y-axis-left-label {
            left: 5px;
            top: 50%;
            transform: rotate(-90deg);
            transform-origin: left;
        }

        #y-axis-right-label {
            right: 5px;
            top: 50%;
            transform: rotate(90deg);
            transform-origin: right;
        }

        #x-axis-label {
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
        }
        


        
    </style>
</head>
<body>
    <h2>BTC Chart</h2>
    <h3 id="chart-label">Current Chart: Daily (1D)</h3> 
    <!-- <label>
        <input type="checkbox" id="sma-checkbox"> SMA-50 (Blue Line)
    </label> -->
    <!-- <label for="sma-select">Choose SMA:</label> -->
    <!-- <select id="sma-select">
        <option value="">None</option>
        <option value="20">SMA-20 Days</option>
        <option value="50">SMA-50 Days</option>
        <option value="200">SMA-200 Days</option>
        <option value="350">SMA-50 Weeks</option>  
        <option value="1400">SMA-200 Weeks</option> 
    </select> -->
    <div id="smaLegend"></div>
    <label for="ema-select">Choose EMA:</label>
    <select id="ema-select">
        <option value="">None</option>
        <option value="20">EMA-20 Days</option>
        <option value="50">EMA-50 Days</option>
        <option value="200">EMA-200 Days</option>
    </select>
    <label>
        <input type="checkbox" id="bb-select"> Bollinger Bands
    </label>
    <label>
        <input type="checkbox" id="rsi-checkbox"> RSI
    </label>
    <label id="fibonacci-options"></label>
    <label id="sma-options"></label>
    <!-- <div id="legend-container">
        <div id="legend">SMA (50) - Blue Line | EMA (50) - Purple Line</div>
    </div> -->
    <div id="chart-container">
        <div id="x-axis-label" class="axis-label">Time</div>
    </div>
    
    <div id="rsi-container">
        Relative Strength Index (RSI)
    </div>
    <button onclick="loadChart('1d')">Daily Chart</button>
    <button onclick="loadChart('4h')">4-Hour Chart</button>
    
    <script>
        let chart, candleSeries,  bollingerUpperSeries = null, bollingerMiddleSeries = null, bollingerLowerSeries = null, smaLines = {},
        fibonacciLines = {}, rsiSeries, rsiChart = null, rsiDashedLines, m2Series, maSeries, emaSeries;
        // let markers;

        async function fetchEvent(chartData) {
            const API_URL = "http://localhost:3000/event-data"; // Fetch from local server

            try {
                let response = await fetch(API_URL);
                let data = await response.json();
                console.log(data);
            } catch (error) {
                console.error("Error fetching event data:", error);
            }
        }

        function fetchNew(chartData){
            let newsData = localStorage.getItem("news_data"); 
            let importantEvents = [];
            const latestCandle = chartData[chartData.length - 1];
            const markerTime = new Date(latestCandle.time * 1000).toISOString().split('T')[0]; 
            if(chartData){
                
                let markers = [{
                            time: '2024-11-05', // Ensure this matches your data format
                            position: 'aboveBar', // Position above the candle
                            color: '#eb251e', // Marker color
                            shape: 'circle', // Shape type
                            text: 'Trump Election' // Label text
                        },
                        {
                            time: markerTime, // Ensure this matches your data format
                            position: 'belowBar', // Position above the candle
                            color: '#cc5118                                                         ', // Marker color
                            shape: 'arrowDown', // Shape type
                            text: `Closing Price: $${latestCandle.close.toFixed(2)}` // Label text
                        }
                    ];
                    
                    if (latestCandle) {
                        candleSeries.setMarkers(markers);
                    } else {
                        console.error('latestCandle is undefined or null');
                    }
            

            if (newsData) {
                try {
                    newsData = JSON.parse(newsData); // Convert from string to JSON
                    console.log("Parsed news data:", newsData);
                    
                    // Check if `feed` exists and is an array
                    if (newsData.feed && Array.isArray(newsData.feed)) {
                        let newsArray = newsData.feed; // Extract the news array
                        console.log("Extracted feed array:", newsArray);

                        // Example filter for important events
                        let importantEvents = newsArray.filter(article =>
                            article.title && ["ETF", "crash", "halving", "election", "stocks"].some(keyword =>
                                article.title.toLowerCase().includes(keyword)
                            )
                        );

                        console.log("Filtered important events:", importantEvents);
                        console.log("First Event Object:", importantEvents);
                        const newMarkers = importantEvents.map(event => {
                        let rawDate = event.time_published || ""; // Get time_published safely
                        let formattedDate = "";

                        // Extract date part (handling formats like 20250326T0)
                        if (/^\d{8}T\d+$/.test(rawDate)) {  // Matches "20250326T0"
                            formattedDate = `${rawDate.substring(0, 4)}-${rawDate.substring(4, 6)}-${rawDate.substring(6, 8)}`;
                        } else if (/^\d{4}-\d{2}-\d{2}$/.test(rawDate)) {  // Already correct format
                            formattedDate = rawDate;
                        } else {
                            console.warn(`Invalid date format detected: ${rawDate}, using fallback.`);
                            formattedDate = "2024-01-01"; // Fallback date
                        }

                        return {
                            time: formattedDate,
                            position: "aboveBar",
                            color: '#eb251e',
                            shape: "circle",
                            text: event.title
                        };
                        
                    });
                    markers = [...markers, ...newMarkers];
                    candleSeries.setMarkers(markers);
                    } else {
                        console.error("⚠️ ERROR: `newsData.feed` is missing or not an array. Full object:", newsData);
                    }
                } catch (error) {
                    console.error("⚠️ ERROR: Failed to parse news data:", error);
                }
            } else {
                console.log("⚠️ No news data found in localStorage.");
            }
            
        }
            
        
            // candleSeries.setMarkers(marker);
        }

        function shortenEventLabel(title) {
            // Common financial and stock-related abbreviations
            const abbreviations = {
                "Federal Reserve": "Fed",
                "Interest Rate": "Rate",
                "Approval": "Approved",
                "Decision": "Dec.",
                "Announces": "",
                "Reports": "",
                "Earnings": "Earnings",
                "Bitcoin": "BTC",
                "Ethereum": "ETH",
                "Halving": "Halving",
                "Merger": "Merge",
                "Market Rally": "Rally",
                "Stock Crash": "Crash",
                "Inflation": "CPI"
            };

            // Split the title into words
            let words = title.split(" ");

            // Replace words with abbreviations where applicable
            let shortenedWords = words.map(word => abbreviations[word] || word);

            // Remove empty words and unnecessary conjunctions
            let filteredWords = shortenedWords.filter(word => word && !["the", "is", "on", "for", "to"].includes(word.toLowerCase()));

            // Join back into a shortened title
            return filteredWords.join(" ");
        }
        // Function to update the legend dynamically
        function updateLegend(indicator, period, color) {
           
            const legendContainer = document.getElementById("smaLegend"); // Use a general container for all legends
            // Check if the legend for this specific indicator already exists
            let existingLegend = document.getElementById(`legend-${indicator}`);
            let leg = document.getElementById(`${indicator}-select`);
            // console.log("line 101", leg);
            // console.log("line 102", indicator);
            let selectedText = null;
            if(indicator=="bb"){
                // console.log("bb");
                selectedText = leg.innerText;
            } else if (indicator == "fib") {
                // console.log("fib");
                selectedText = getFibonacciLevel();
                // console.log(selectedText);
            }else if (indicator == "SMA"){
                selectedText = getSMAPeriod();
                // console.log("SMA");
            }
            else{ //for ema and sma (single option)
                // console.log("Im else");
                selectedText = leg.options[leg.selectedIndex].innerText;
                // console.log("EMA");
            }
            // console.log("line 108", selectedText);
           // if period == "None"
            if(isNaN(period)){
                if(existingLegend){
                    legendContainer.removeChild(existingLegend);
                }
                return;
            }
            if (existingLegend) {
                // Remove the existing legend for the same indicator before adding a new one
                legendContainer.removeChild(existingLegend);
            }
            //if 0 go here
            // Create a new legend item if it doesn’t exist
            const legendItem = document.createElement("div");
            legendItem.id = `legend-${indicator}`;  // Unique ID for each legend
            legendItem.style.color = color;
            legendItem.style.fontSize = "14px";
            legendItem.style.fontWeight = "bold";
            if(indicator!="bb")
                legendItem.innerText = selectedText;
            else
                legendItem.innerText = "Bollinger Bands";
            // console.log("line 119",legendItem.id)
            // Append new legend item
            
            legendContainer.appendChild(legendItem);
            
            updateLegendBorder();
            
        }

        function updateLegendBorder() {
            const legendContainer = document.getElementById("smaLegend");

            if (legendContainer.childElementCount === 0) {
                // If empty, use dashed border
                legendContainer.style.border = "0px";
            } 
            else {
                // If has items, use solid border
                legendContainer.style.border = "2px solid #b3bab3";
            }
            
        }
        
        async function fetchData(timeframe) {
            try {
                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${timeframe}&limit=1000`);
                const data = await response.json();
                console.log("📊 Data Length:", data.length); //150
                return data.map(d => ({
                    time: d[0] / 1000,
                    open: parseFloat(d[1]),
                    high: parseFloat(d[2]),
                    low: parseFloat(d[3]),
                    close: parseFloat(d[4]),
                    volume: parseFloat(d[5])
                }));
                
            } catch (error) {
                console.error("❌ Error fetching data:", error);
            }
        }

        async function fetchM2() {
            const API_URL = "http://localhost:3000/m2-data"; // Fetch from local server

            try {
                let response = await fetch(API_URL);
                let data = await response.json();
                let observations = data.observations;
                let m2Data = observations.map(d => ({
                    time: d.date,  // Ensure format is YYYY-MM-DD
                    value: parseFloat(d.value)
                }));
               m2Series.setData(m2Data); // Update M2 series in LightweightCharts
               if (m2Data.length > 0) {
                    let latestM2 = m2Data[m2Data.length - 1]; // Get the latest data point

                    m2Series.setMarkers([
                        {
                            time: latestM2.time,  // Ensure this matches the format in setData()
                            position: 'aboveBar', // Position marker above the data point
                            color: '#FFD700',     // Marker color
                            shape: 'arrowDown',   // Shape type
                            text: `M2: ${latestM2.value}` // Display the value
                        }
                    ]);
                }
            } catch (error) {
                console.error("Error fetching M2 data:", error);
            }
        }

        // function plotM2Chart(labels, values) {
        //     let ctx = document.getElementById("m2Chart").getContext("2d");
        //     console.log("plotting m2");
        //     new Chart(ctx, {
        //         type: "line",
        //         data: {
        //             labels: labels,
        //             datasets: [
        //                 {
        //                     label: "M2 Money Supply",
        //                     data: values,
        //                     borderColor: "blue",
        //                     yAxisID: "yM2",  // Assign this dataset to a separate Y-axis
        //                     fill: false
        //                 }
        //             ]
        //         },
        //         options: {
        //             responsive: true,
        //             scales: {
        //                 x: {
        //                     type: "time",
        //                     time: { unit: "month" },
        //                     text: "Time (Month)"
        //                 },
        //                 yM2: {  // Define the separate Y-axis for M2
        //                     position: "left",
        //                     beginAtZero: false,
        //                     title: {
        //                         display: true,
        //                         text: "M2 Money Supply"
        //                     }
        //                 }
        //             }
        //         }
        //     });
        // }
       
        function calculateSMA(data, period) {
            let smaData = [];
            for (let i = period - 1; i < data.length; i++) { //i=19 until 100
                let sum = 0;
                for (let j = 0; j < period; j++) { //j<19
                    sum += data[i - j].close;
                }
                let avg = sum / period;
                smaData.push({ time: data[i].time, value: avg });
            }
            // console.log("period", period); //81 sma (100-19)
            return smaData;
        }

        function calculateEMA(data, period) {
            let emaData = [];
            let multiplier = 2 / (period + 1); // Smoothing factor 2/21

            // Start with the first SMA as the initial EMA value
            let sum = 0;
            for (let i = 0; i < period; i++) {// i<50
                sum += data[i].close;
            }
            let prevEMA = sum / period;
            if (data[period - 1]) {
                // console.log("Im here");
                emaData.push({ time: data[period - 1].time, value: prevEMA });
            }

            // Calculate EMA for the rest
            for (let i = period; i < data.length; i++) {
                let ema = (data[i].close - prevEMA) * multiplier + prevEMA;
                emaData.push({ time: data[i].time, value: ema });
                prevEMA = ema;
            }
            return emaData;
        }

        function calculateBollingerBands(data, period = 20, multiplier = 2) {
            let bands = [];

            for (let i = period - 1; i < data.length; i++) {
                let slice = data.slice(i - period + 1, i + 1); // Get last `period` values
                let sma = slice.reduce((sum, d) => sum + d.close, 0) / period;

                // Calculate standard deviation
                let variance = slice.reduce((sum, d) => sum + Math.pow(d.close - sma, 2), 0) / period;
                let stdDev = Math.sqrt(variance);

                let upperBand = sma + (stdDev * multiplier);
                let lowerBand = sma - (stdDev * multiplier);

                bands.push({ time: data[i].time, middle: sma, upper: upperBand, lower: lowerBand });
            }
            return bands;
        }

        function removeBollingerBands() {
            if (bollingerUpperSeries) {
                chart.removeSeries(bollingerUpperSeries);
                bollingerUpperSeries = null;
            }
            if (bollingerLowerSeries) {
                chart.removeSeries(bollingerLowerSeries);
                bollingerLowerSeries = null;
            }
            if (bollingerMiddleSeries) {
                chart.removeSeries(bollingerMiddleSeries);
                bollingerMiddleSeries = null;
            }
        }

        function calculateFibonacciLevels(high, low) {
            return {
                0.0: high - (0.0 * (high - low)),
                0.236: high - (0.236 * (high - low)),
                0.382: high - (0.382 * (high - low)),
                0.5: high - (0.5 * (high - low)),
                0.618: high - (0.618 * (high - low)),
                0.786: high - (0.786 * (high - low)),
                1.0: high - (1.0 * (high - low)),
            };
        }

        function toggleFibonacciLevel(level, value, checked) {
            if (checked) {
                if (!fibonacciLines[level]) {
                    fibonacciLines[level] = candleSeries.createPriceLine({
                        price: value,
                        color: '#edb90e', 
                        lineWidth: 1,
                        lineStyle: 2, // Dashed Line
                        axisLabelVisible: true, // Show label on the price axis
                        title: `Fib ${level}%` // Label for the Fibonacci level
                    });
                }
            } else {
                if (fibonacciLines[level]) {
                    candleSeries.removePriceLine(fibonacciLines[level]);
                    delete fibonacciLines[level];
                }
            }

            // Update legend based on remaining Fibonacci levels
            // const remainingLevels = Object.keys(fibonacciLines);
            // if (remainingLevels.length > 0) {
            //     updateLegend("fib", 0, "#edb90e");
            // } else {
            //     updateLegend("fib", "None", "#73c769");
            // }
        }

        function createFibonacciCheckboxes(chartData) {
            const fibContainer = document.getElementById("fibonacci-options");
            fibContainer.innerHTML = ""; // Clear existing checkboxes

            const high = Math.max(...chartData.map(d => d.high));
            const low = Math.min(...chartData.map(d => d.low));
            const fibLevels = calculateFibonacciLevels(high, low);

            // Create dropdown container
            const details = document.createElement("details");
            const summary = document.createElement("summary");
            summary.innerText = "Select Fibonacci Levels";
            
            details.appendChild(summary);

            const checkboxContainer = document.createElement("div");
            checkboxContainer.style.display = "flex";
            checkboxContainer.style.flexDirection = "column";
            checkboxContainer.style.padding = "8px";

            Object.entries(fibLevels)
            .sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]))
            .forEach(([level, value]) => {
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.id = `fib-${level}`;
                checkbox.value = level;
                checkbox.addEventListener("change", function () {
                    toggleFibonacciLevel(level, value, this.checked, chartData);
                });

                const label = document.createElement("label");
                label.htmlFor = `fib-${level}`;
                label.innerText = `Fib ${level}`;

                const div = document.createElement("div");
                div.style.display = "flex";
                div.style.alignItems = "center";
                div.style.gap = "5px";

                div.appendChild(checkbox);
                div.appendChild(label);
                checkboxContainer.appendChild(div);
            });

            details.appendChild(checkboxContainer);
            fibContainer.appendChild(details);
        }

        function getFibonacciLevel() {
            const selectedLevel = [];
            const checkboxes = document.querySelectorAll("#fibonacci-options input[type='checkbox']:checked");
            
            if (!checkboxes) return []; // Ensure it always returns an array

            checkboxes.forEach((checkbox) => {
                const label = document.querySelector(`label[for="${checkbox.id}"]`);
                if (label) {
                    selectedLevel.push(label.innerText);
                }
            });

            console.log("Selected Fibonacci Levels:", selectedLevel);
            return selectedLevel.length ? selectedLevel.join("\n ") : []; // Always return an array
        }

        function getSMAPeriod() {
            const selectedPeriod = [];
            const checkboxes = document.querySelectorAll("#sma-options input[type='checkbox']:checked");
            
            if (!checkboxes) return []; // Ensure it always returns an array

            checkboxes.forEach((checkbox) => {
                const label = document.querySelector(`label[for="${checkbox.id}"]`);
                if (label) {
                    selectedPeriod.push(label.innerText);
                }
            });

            console.log("Selected SMA Periods:", selectedPeriod);
            return selectedPeriod.length ? selectedPeriod.join("\n ") : []; // Always return an array
        }

        function toggleSMA(period, checked, chartData) {
            const smaColors = {
                20: '#1e95e3',  // Green for 20-period SMA
                50: '#227bb5',  // Blue for 50-period SMA
                100: '#22648f', // Purple for 100-period SMA
                200: '#1c4763'  // Orange for 200-period SMA
            };
            const color = smaColors[period];
            if (checked) {
                if (!smaLines[period]) {
                    // console.log(smaLines[period]);
                    
                    smaLines[period] = chart.addLineSeries({
                        color: color, 
                        lineWidth: 2, 
                        lineStyle: 0 // Solid Line
                    });
                }

                const smaData = calculateSMA(chartData, period);
                smaLines[period].setData(smaData);
            } else {
                if (smaLines[period]) {
                    chart.removeSeries(smaLines[period]);
                    delete smaLines[period];
                }
            }

            // const remainingSMAs = Object.keys(smaLines);
            // if (remainingSMAs.length > 0) {
            //     updateLegend("SMA", 0, color);
            // } else {
            //     updateLegend("SMA", "None", color);
            // }
        }

        function createSMACheckboxes(chartData) {
            const smaContainer = document.getElementById("sma-options");
            smaContainer.innerHTML = ""; // Clear existing checkboxes

            const smaPeriods = [20, 50, 100, 200]; // Common SMA periods

            const details = document.createElement("details");
            const summary = document.createElement("summary");
            summary.innerText = "Select SMA Periods";
            details.appendChild(summary);

            const checkboxContainer = document.createElement("div");
            checkboxContainer.style.display = "flex";
            checkboxContainer.style.flexDirection = "column";
            checkboxContainer.style.padding = "8px";

            smaPeriods.forEach(period => {
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.id = `sma-${period}`;
                checkbox.value = period;
                checkbox.addEventListener("change", function () {
                    toggleSMA(period, this.checked, chartData);
                });

                const label = document.createElement("label");
                label.htmlFor = `sma-${period}`;
                label.innerText = `SMA ${period}`;

                const div = document.createElement("div");
                div.style.display = "flex";
                div.style.alignItems = "center";
                div.style.gap = "5px";

                div.appendChild(checkbox);
                div.appendChild(label);
                checkboxContainer.appendChild(div);
            });

            details.appendChild(checkboxContainer);
            smaContainer.appendChild(details);
        }

        function calculateRSI(data, period = 14) {
            let gains = [];
            let losses = [];

            // Step 1: Compute gains & losses
            for (let i = 1; i < data.length; i++) {
                let change = data[i].close - data[i - 1].close;
                gains.push(change > 0 ? change : 0);
                losses.push(change < 0 ? Math.abs(change) : 0);
            }

            // Step 2: Compute initial average gain/loss
            let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
            let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;

            let rsi = [];

            // Step 3: Compute RSI for each period
            for (let i = period; i < gains.length; i++) {
                avgGain = (avgGain * (period - 1) + gains[i]) / period;
                avgLoss = (avgLoss * (period - 1) + losses[i]) / period;

                let rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                let rsiValue = 100 - (100 / (1 + rs));

                rsi.push({ time: data[i + 1].time, value: rsiValue });
            }

            return rsi;
        }

        async function loadChart(timeframe) {
            document.getElementById("smaLegend").innerHTML = "";
            updateLegendBorder();
            const binanceTimeframe = timeframe === '1d' ? '1d' : '4h';
            const chartData = await fetchData(binanceTimeframe);
            // console.log(chartData.d)
            const high = Math.max(...chartData.map(d => d.high));
            const low = Math.min(...chartData.map(d => d.low));
            //const smaCheckbox = document.getElementById('sma-checkbox');
            // const emaCheckbox = document.getElementById('ema-checkbox');
            const bbCheckbox = document.getElementById('bb-select');
            const rsiCheckbox = document.getElementById('rsi-checkbox');
            let smaSelect = document.getElementById('sma-select');
            let emaSelect = document.getElementById('ema-select');
            if (chartData) {
                const latestCandle = chartData[chartData.length - 1];
                console.log("Loading chart for:", timeframe);
                // smaSelect.value = "";
                emaSelect.value = "";
                // Remove old series before adding a new one
                Object.values(fibonacciLines).forEach(series => {
                    chart.removeSeries(series);
                });
                fibonacciLines = {}; 
                
                if (candleSeries) chart.removeSeries(candleSeries);
                if (maSeries) { chart.removeSeries(maSeries); maSeries = null; }
                if (emaSeries) { chart.removeSeries(emaSeries); emaSeries = null; }
                //if (rsiSeries) { chart.removeSeries(rsiSeries); rsiSeries = null; }
                removeBollingerBands();
                // if (bollingerUpperSeries) chart.removeSeries(bollingerUpperSeries);
                // if (bollingerLowerSeries) { chart.removeSeries(bollingerLowerSeries); bollingerLowerSeries = null; }
                // if (bollingerMiddleSeries) { chart.removeSeries(bollingerMiddleSeries); bollingerMiddleSeries = null; }


                candleSeries = chart.addCandlestickSeries();
                candleSeries.setData(chartData);
                fetchNew(chartData);
                

                // setEvent(candleSeries);
                console.log(candleSeries._private__markers); // Internal marker storage
                console.log(candleSeries.options().markers); // Public API (if available)
                createFibonacciCheckboxes(chartData);
                createSMACheckboxes(chartData);
                bbCheckbox.checked = false;
                rsiCheckbox.checked = false;
                

                // Remove previous event listeners before adding new ones
                
                //smaCheckbox.checked = false;
                // emaCheckbox.checked = false;
                
                // removeIndicator(smaCheckbox)
                // console.log("can 2")
                // const newSmaCheckbox = smaCheckbox.cloneNode(true);
                // const newEmaCheckbox = emaCheckbox.cloneNode(true);
                
                // smaCheckbox.parentNode.replaceChild(newSmaCheckbox, smaCheckbox);
                // emaCheckbox.parentNode.replaceChild(newEmaCheckbox, emaCheckbox);

                // Ensure RSI Chart Exists
                if (!rsiChart) {
                    rsiChart = LightweightCharts.createChart(document.getElementById('rsi-container'), {
                        width: document.getElementById('rsi-container').clientWidth,
                        height: 200,
                        layout: { backgroundColor: '#ffffff', textColor: '#000' },
                        grid: { vertLines: { color: '#eeeeee' }, horzLines: { color: '#eeeeee' } }
                    });
                }

                // Remove old RSI series if exists
                if (rsiSeries) {
                    rsiChart.removeSeries(rsiSeries);
                    rsiSeries = null;
                }
                
                // smaSelect.addEventListener('change', function () {
                //     if (maSeries) chart.removeSeries(maSeries);  // Remove previous SMA line
        
                //     const selectedPeriod = parseInt(this.value);
                //     updateLegend("sma", selectedPeriod, "#3279a8"); 
                //     // console.log("Sma period", selectedPeriod);
                //     //if (!selectedPeriod) return;  // If "None" is selected, do nothing
                //     const smaData = calculateSMA(chartData, selectedPeriod);
                //     maSeries = chart.addLineSeries({ color: '#3279a8', lineWidth: 2 });
                //     maSeries.setData(smaData);
                //     //console.log("line 452",selectedPeriod)
                    
                // });

                emaSelect.addEventListener('change', function () {
                    if (emaSeries) chart.removeSeries(emaSeries);  // Remove old EMA before adding new one
                    const selectedPeriod = parseInt(this.value);
                    // console.log("Ema period", selectedPeriod);
                    // if (!selectedPeriod) return;  // If "None" is selected, do nothing
                    // updateLegend("ema", selectedPeriod, "#73c769"); 
                    
                    const emaData = calculateEMA(chartData, selectedPeriod);
                    emaSeries = chart.addLineSeries({ color: '#f58747', lineWidth: 2 });
                    emaSeries.setData(emaData);
                    //updateLegend("ema", selectedPeriod, "#73c769"); 
                });
              
                bbCheckbox.addEventListener('change', function () {
                    if (this.checked) {
                        const bollingerData = calculateBollingerBands(chartData, 20, 2);
                        if (!bollingerUpperSeries){
                            // Middle Band (SMA)
                            bollingerMiddleSeries = chart.addLineSeries({ color: '#7242a6', lineWidth: 2 , lineStyle: 2});
                            bollingerMiddleSeries.setData(bollingerData.map(d => ({ time: d.time, value: d.middle })));

                            // Upper Band
                            bollingerUpperSeries = chart.addLineSeries({ color: '#8c50cc', lineWidth: 2 });
                            bollingerUpperSeries.setData(bollingerData.map(d => ({ time: d.time, value: d.upper })));

                            // Lower Band
                            bollingerLowerSeries = chart.addLineSeries({ color: '#8c50cc', lineWidth: 2 });
                            bollingerLowerSeries.setData(bollingerData.map(d => ({ time: d.time, value: d.lower })));

                            updateLegend("bb", 0, "#8c50cc"); 
                        }
                    } 
                    else {
                        removeBollingerBands();
                        updateLegend("bb", "None", "#8c50cc"); 
                    }
                });

                rsiCheckbox.addEventListener('change', function () {
                    if (!rsiChart) return;
                    if (this.checked) {
                        if (rsiSeries) {
                            rsiChart.removeSeries(rsiSeries); // Remove previous RSI series
                        }
                        const rsiData = calculateRSI(chartData, 14);

                        rsiSeries = rsiChart.addLineSeries({
                            color: '#9467bd',
                            lineWidth: 2,
                        });

                        rsiSeries.setData(rsiData);
                        if (!rsiDashedLines) {
                            rsiDashedLines = [
                                rsiChart.addLineSeries({
                                    color: '#00FF00', 
                                    lineWidth: 1,
                                    lineStyle: 2, // Dashed line
                                }),
                                rsiChart.addLineSeries({
                                    color: '#00FF00', 
                                    lineWidth: 1,
                                    lineStyle: 2, //
                                }),
                            ];

                            const minTime = rsiData[0].time;
                            const maxTime = rsiData[rsiData.length - 1].time;

                            rsiDashedLines[0].setData([{ time: minTime, value: 70 }, { time: maxTime, value: 70 }]);
                            rsiDashedLines[1].setData([{ time: minTime, value: 30 }, { time: maxTime, value: 30 }]);
                        }
                    } else {
                        if (rsiSeries) { 
                            rsiChart.removeSeries(rsiSeries); rsiSeries = null; 
                        }
                    }
                    
                });

                // m2Data = 
                // m2Series.setData(m2Data);
                document.title = `BTC ${timeframe.toUpperCase()} - $${latestCandle.close.toFixed(2)}`;
                document.getElementById("chart-label").innerText = `Current Chart: ${timeframe === '1d' ? 'Daily (1D)' : '4-Hour (4H)'}`;
                         
            }
        }

        window.onload = async function() {
            console.log(LightweightCharts);
            if (typeof LightweightCharts === "undefined") {
                console.error("🚨 LightweightCharts is NOT loaded! Check your script tag.");
                return;
            }
            
            const chartContainer = document.getElementById('chart-container');
            if (!chartContainer) {
                console.error("Chart container not found!");
                return;
            }
            chart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth,
                height: 600,
                layout: { backgroundColor: '#ffffff', textColor: '#000' },
                grid: { vertLines: { color: '#eeeeee' }, horzLines: { color: '#eeeeee' } },
                rightPriceScale: { visible: true, borderColor: '#d1d4dc' }, // BTC on right axis
                leftPriceScale: { visible: true, borderColor: '#d1d4dc' }   // M2 on left axis
            });

            // Add BTC Candlestick Series (Right Axis)
            candleSeries = chart.addCandlestickSeries({ priceScaleId: 'right' });

            //Add M2 Line Series (Left Axis)
            m2Series = chart.addLineSeries({
                color: '#FFD700', // Red for visibility
                lineWidth: 2,
                priceScaleId: 'left',
                
            });

            await loadChart('1d'); // Load default chart
            await fetchM2(m2Series);

            // Create the tooltip div
            const tooltip = document.createElement("div");
            tooltip.style.position = "absolute";
            tooltip.style.background = "rgba(255, 255, 255, 0.9)";
            tooltip.style.padding = "5px";
            tooltip.style.borderRadius = "5px";
            tooltip.style.border = "1px solid #ccc";
            tooltip.style.fontSize = "14px";
            tooltip.style.display = "none";
            tooltip.style.pointerEvents = "none"; // Prevents tooltip from interfering with mouse events
            tooltip.style.zIndex = "1000"; // Ensures tooltip appears above everything
            document.body.appendChild(tooltip);
            const smaColors = {
                20: '#1e95e3',  // Green for 20-period SMA
                50: '#227bb5',  // Blue for 50-period SMA
                100: '#22648f', // Purple for 100-period SMA
                200: '#1c4763'
            };

            // Function to handle tooltip on hover
            chart.subscribeCrosshairMove(param => {
                if (!param || !param.point || !param.seriesData) {
                    tooltip.style.display = "none";
                    return;
                }

                const { point, seriesData } = param;
                let text = "";

                // Loop through SMA lines and check if they have data at the hovered point
                Object.keys(smaLines).forEach(period => {
                    if (seriesData.has(smaLines[period])) {
                        const value = seriesData.get(smaLines[period]).value;
                        text += `<b style="color: ${smaColors[period]};">SMA ${period}:</b> ${value.toFixed(2)}<br>`;
                    }
                });

                Object.keys(fibonacciLines).forEach(level => {
                    if (seriesData.has(fibonacciLines[level])) {
                        const value = seriesData.get(fibonacciLines[level]).value;
                        text += `<b>Fibonacci ${level}:</b> ${value.toFixed(2)}<br>`;
                    }
                });

                const ema = document.getElementById("ema-select").value;
                if (ema && emaSeries) {  // Check if EMA is selected and exists
                    if (seriesData.has(emaSeries)) {
                        const value = seriesData.get(emaSeries).value;
                        const color = "#f58747";
                        text += `<b style="color: ${color};">EMA ${ema}:</b> ${value.toFixed(2)}<br>`;
                    }
                }


                if (text !== "") {
                    tooltip.innerHTML = text;
                    tooltip.style.left = `${point.x + 10}px`;
                    tooltip.style.top = `${point.y - 10}px`;
                    tooltip.style.display = "block";
                } else {
                    tooltip.style.display = "none";
                }
            });
        };
    </script>
</body>
</html>
