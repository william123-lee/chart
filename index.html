<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display&family=Lato&display=swap" rel="stylesheet">
    <!--<title>BTC Chart - Lightweight Version</title>-->
    <link href="https://fonts.googleapis.com/css2?family=Exo&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js" async></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/technicalindicators@3.0.1/dist/browser/technicalindicators.min.js" async></script> -->
    <style>
        /* body{
            background-color: #121212;
            color: #ffffff;
        } */
        h2 {
            font-family: 'Exo', sans-serif;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            
        }
        .chart-tooltip {
            font-family: 'Lato', sans-serif;
            font-size: 14px;
            color: #fff;
        }

        body {
            font-family: 'Lato', sans-serif;
            
        }
        #chart-container {
            width: 100%;
            height: 650px;
            position: relative;
            /*background-color: #1e1e1e;*/
            margin-bottom: 20px;
        }
        
        button {
            margin-top: 10px;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            color:#094d91;
            font-family: 'Lato', sans-serif;
        }
        #chart-label {
            font-size: 20px;
            font-weight: bold;
            margin-top: 10px;
        }
        #indicator-controls {
            position: absolute;
            top: 10px;
            right: 20px;
            margin-bottom: 20px;
            z-index: 1000;
        }

        #indicator-controls button {
            padding: 6px 12px;
            background-color: #c2d4f2;
            color: #011A41;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Lato', sans-serif;
        }

        #indicator-controls button:hover {
            background-color: #4684e8;
        }
        #indicator-controls-wrapper {
            display: flex; 
            gap: 20px; 
            align-items: flex-start;
        }
        #smaLegend {
            position: absolute;
            right: 20px;
            top: 80px;
            width: 100px;
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2); 
            text-align: left;
        }
        input[type="checkbox"] {
            accent-color: #094d91; /* modern blue */

            cursor: pointer;
        }
        select {
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: #f9f9f9;
            color: #094d91;
            outline: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        select:hover {
            border-color: #094d91;
            background-color: #eef5fc;
        }

        .axis-label {
            position: absolute;
            font-size: 14px;
            font-weight: bold;
            color: #000;
        }

        #y-axis-left-label {
            left: 5px;
            top: 50%;
            transform: rotate(-90deg);
            transform-origin: left;
        }

        #y-axis-right-label {
            right: 5px;
            top: 50%;
            transform: rotate(90deg);
            transform-origin: right;
        }

        #x-axis-label {
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
        }
        .news-container {
            position: absolute;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 12px;
            background-color: #fff;
            box-shadow: 0 6px 16px rgba(0,0,0,0.12);
            z-index: 1000;
            display: none;
            pointer-events: auto;
            width: 360px;
            max-height: 480px;
            overflow-y: auto;
            color: #222;
            line-height: 1.6;
            font-family: 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
        }

        .news-article {
            margin-bottom: 16px;
        }

        .news-article b {
            font-size: 15px;
            color: #000;
        }

        .news-article small {
            display: block;
            margin-top: 4px;
            color: #555;
        }

        .news-article a {
            color: #1a0dab;
            text-decoration: none;
        }

        .news-article a:hover {
            text-decoration: underline;
        }

        .news-article hr {
            margin-top: 12px;
            border: none;
            border-top: 1px solid #eee;
        }
        
    </style>
</head>
<body>
    <h2 style="color: #011A41">BTC Chart</h2>
    <h3 id="chart-label" style="color: #011A41">Current Chart: Daily (1D)</h3> 
    <div id="indicator-controls-wrapper">
        <div id="indicator-controls">
            <button onclick="clearAllIndicators()"> Clear All Indicators</button>
        </div>
        <div id="smaLegend"></div>
        <label for="ema-select">EMA:</label>
        <select id="ema-select">
            <option value="">None</option>
            <option value="20">EMA-20 Days</option>
            <option value="50">EMA-50 Days</option>
            <option value="200">EMA-200 Days</option>
        </select>
        <label>
            <input type="checkbox" id="bb-select"> Bollinger Bands
        </label>
        <label>
            <input type="checkbox" id="rsi-checkbox"> RSI
        </label>
        <label>
            <input type="checkbox" id="super-checkbox"> Supertrend
        </label>
        <label>
            <input type="checkbox" id="sent-checkbox"> Sentiment Analysis
        </label>
        
        <div id="sma-options"></div>
        <div id="fibonacci-options"></div>
        <div id="ichimoku-options"></div> 
        <label for="analysis-select">Analysis Indicators:</label>
        <select id="analysis-select">
            <option value="">None</option>
            <option value="m2">M2</option>
            <option value="mvrv">MVRV</option>
        </select>      
    </div>
    
    <!-- <label id="ichimoku-options"></label>
    <label id="fibonacci-options"></label>
    <label id="sma-options"></label> -->
    <div id="chart-container">
        <div id="x-axis-label" class="axis-label">Time</div>
        
    </div>
    
    <div id="rsi-container">
        Relative Strength Index (RSI)
    </div>
    <button onclick="loadChart('1d')">Daily Chart</button>
    <button onclick="loadChart('4h')">4-Hour Chart</button>
    <button onclick="loadChart('1w')">Weekly Chart</button>
    
    <script>
        let chart, chartData = [], candleSeries,  bollingerUpperSeries = null, bollingerMiddleSeries = null, bollingerLowerSeries = null, smaLines = {},
        fibonacciLines = {}, rsiSeries, rsiChart = null, rsiDashedLines, m2Series, emaSeries, sentimentSeries, baseSentimentSeries,
        topSentimentSeries, lineSeries, stepSeries, supertrendSeries = [], supertrendDownSeries, sma50 = null, sma200 = null, sma365 = null, commentaries, bbAlerts = [], 
        markers = [], unixTime = null, tweetData = [], ichimokuLine = {}, updatedMvrvData = null, mvrvSeries, signals = [], newsBoxVisible, tweetBoxVisible, time = null, supertrendSegments = []; 
        
        const tweetBox = document.createElement("div");
            tweetBox.id = "tweetBox";
            tweetBox.style.position = "absolute";
            // tweetBox.style.top = "100px";
            // tweetBox.style.left = "10px";
            tweetBox.style.padding = "16px";
            tweetBox.style.border = "1px solid #7d7c7c";
            tweetBox.style.borderRadius = "12px";
            tweetBox.style.backgroundColor = "#ffffff";
            tweetBox.style.boxShadow = "0 4px 12px rgba(0,0,0,0.08)";
            tweetBox.style.zIndex = "1000";
            tweetBox.style.display = "none";
            tweetBox.style.pointerEvents = "auto";
            tweetBox.style.width = "320px";
            tweetBox.style.maxHeight = "400px";
            tweetBox.style.overflowY = "auto";
            tweetBox.style.color = "#333";
            tweetBox.style.lineHeight = "1.5";
            document.body.appendChild(tweetBox);

            const newBox = document.createElement("div");
            newBox.id = "tweetBox";
            newBox.className = "news-container";
            document.body.appendChild(newBox);

        //HERE is to fetch the social domaninance from santiment
        //then overlay it with the btc chart

        // ** FETCHING DATA ** //
        // HERE is to fetch the BTC data from binanceAPI
        // timeframe is either '1d' or '4hr' or '1w'
        async function fetchData(timeframe) {
            try {
                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${timeframe}&limit=1000`);
                // const response = await fetch(`https://www.alphavantage.co/query?function=DIGITAL_CURRENCY_DAILY&symbol=BTC&market=USD&apikey=9WHCIQDMR3UZ2W1J`);
                const data = await response.json();

                console.log("ðŸ“Š Data Length:", data.length); //1000
                //volume can be ignore
                return data.map(d => ({
                    time: d[0] / 1000,
                    open: parseFloat(d[1]),
                    high: parseFloat(d[2]),
                    low: parseFloat(d[3]),
                    close: parseFloat(d[4]),
                    volume: parseFloat(d[5])
                }));
                
            } catch (error) {
                console.error("âŒ Error fetching data:", error);
            }
        }

        // fetching mvrv data
        async function fetchMVRV(){
            try{
                const response = await fetch('http://localhost:3000/mvrv-data');
                const data = await response.json();
                if (data?.responseData?.getMetric?.timeseriesData) {
                    const mvrvData = data.responseData.getMetric.timeseriesData;
                    displayMVRVChart(mvrvData);
                    // console.log(mvrvData);
                } else {
                    console.error("No MVRV data available");
                }
            } catch(err){
                console.error("Failed to fetch MVRV data", err);
            }
        }

        function displayMVRVChart(mvrvData){
            updatedMvrvData = mvrvData.map(item => {
                if (item.datetime) {
                    // Create a Date object from the datetime string
                    const date = new Date(item.datetime);
                    
                    // Format the date as "YYYY-MM-DD" (You can adjust the format as needed)
                    const formattedDate = date.toISOString().split('T')[0]; // "YYYY-MM-DD" format

                    // Return the new object with the formatted date
                    return {
                        
                        time: formattedDate,
                        value: item.value // Store the formatted date
                    };
                }
            });

            mvrvSeries = chart.addLineSeries({
                color: '#d99696', 
                lineWidth: 2,
                priceScaleId: 'left',
                
            });

            mvrvSeries.setData(updatedMvrvData); // Update M2 series in LightweightCharts
        }

        function detectMVRVandSMA(){
            const smaMap = new Map();
                sma365.forEach(item => {
                    const date = new Date(item.time * 1000).toISOString().slice(0, 10); // Convert to 'YYYY-MM-DD'
                    smaMap.set(date, item.value);
                });
            // console.log(smaMap);

            // First, find min/max across the entire dataset
            const mvrvValues = updatedMvrvData.map(d => d.value);
            const smaValues = updatedMvrvData.map(d => smaMap.get(d.time.slice(0, 10))).filter(v => v !== undefined);

            const minMvrv = Math.min(...mvrvValues);
            const maxMvrv = Math.max(...mvrvValues);
            const minSma = Math.min(...smaValues);
            const maxSma = Math.max(...smaValues);
            signals = [];
            let previousSignal = null;
            updatedMvrvData.forEach(item => {
                const date = item.time.slice(0, 10);
                const mvrv = item.value;
                const sma = smaMap.get(date);

                if (sma !== undefined) {
                    const normMvrv = (mvrv - minMvrv) / (maxMvrv - minMvrv);
                    const normSma = (sma - minSma) / (maxSma - minSma);
                    let currentSignal = null;
                    const diff = normMvrv - normSma;
                    let text = null;
                    if (diff > 0) {
                        currentSignal = 'Above SMA';
                        text = 'MVRV is above SMA';
                    } else if (diff < 0) {
                        currentSignal = 'Below SMA'
                        text = 'MVRV is below SMA';
                    } else {
                        currentSignal = 'Equal to SMA';
                        text = 'MVRV is equal to SMA';
                    }

                    if(currentSignal !== previousSignal){
                        signals.push({date, signal:text, diff});
                        previousSignal = currentSignal;
                    }
                }
            });  
            console.log(signals);                                   
        }
        
        // fetching twitter post - now fetching manually
        async function fetchTwitter(){
            // fetch('http://localhost:3000/twitter-post')
            // .then(response => response.json())
            // .then(data => {
            //     console.log("Username:", data.username);
            //     console.log("Text:", data.text);
            //     console.log("Timestamp:", data.timestamp);
            //     const name = data.username;
            //     const text = data.text;
            //     const timestamp = data.timestamp;
                
            //     tweetData = {
            //         username: name,
            //         text: text,
            //         timestamp: timestamp
            //     };
            
            //     const tweetDate = new Date(timestamp);
            //     unixTime = Math.floor(tweetDate.getTime()/1000);
            //     console.log(timestamp);
            //     tweetDate.setUTCHours(0, 0, 0, 0);
            //     console.log(tweetDate);
            //     const normalizedUnixTime = Math.floor(tweetDate.getTime() / 1000);
            //     console.log(normalizedUnixTime);
            //     const twitMarker = [{
            //         time: normalizedUnixTime,
            //         position: 'belowBar', 
            //         color: '#1DA1F2', // Twitter blue
            //         shape: 'square', 
            //         text: 'ðŸ¦ Twitter Analysis', 
            //     }];
            //     setMarkers(twitMarker);
            // })
            // .catch(error => {
            //     console.error("Error fetching tweet info:", error);
            // });

            const name = "CryptoHayes";
            const text = "I bet $BTC hits $110k before it retests $76.5k.\n Y? The Fed is going from QT to QE for treasuries. And tariffs donâ€™t matter cause â€œtransitory inflationâ€. JAYPOW told me so.\n Iâ€™ll expound on that in my next essay, thatâ€™s the TLDR for your TikTok peanut brain."
            const timestamp = "2025-03-24T02:42:09.000Z";
            const profile = 'https://pbs.twimg.com/profile_images/1860844599088189440/dH1AnJGk_normal.jpg';
            tweetData.push ({
                username: name,
                text: text,
                timestamp: timestamp,
                profile: profile,
                tweetID: '1904000755381760058'
            });

            tweetData.push({
                username: "test",
                text: "testText",
                timestamp: "2025-04-14T02:42:09.000Z",
                tweetID: '1904000755381760050'
            })
           

            const date = new Date(timestamp).toISOString().split("T")[0];
            let twitMarker = [{
                time:date,
                position: 'belowBar', 
                color: '#1a4670', // Twitter blue
                shape: 'circle', 
                size: 2,
                text: 'Analysis', 
            },
            {
                time: { year: 2025, month: 4, day: 14},
                position: 'belowBar', 
                color: '#1a4670', // Twitter blue
                shape: 'circle', 
                size: 2,
                text: 'Analysis', 
            }];
            setMarkers(twitMarker);

            
            tweetBoxVisible = false;
            chart.subscribeClick(function (param) {
                if (!param || !param.time) return;

                // Check if the click was on the marker (mouse's movement)
                const clickedTime = param.time;
                // console.log(isSameDate(clickedTime, unixTime));
                    const x = param.point.x;
                    const y = param.point.y;
                    // console.log(x,y);
                    if (tweetBoxVisible) {
                        // If tweetBox is visible, hide it
                        tweetBox.style.display = "none";
                        tweetBoxVisible = false;
                    }else {
                        // If tweetBox is not visible, show it and position it
                        if(newsBoxVisible){
                            newBox.style.display = "none";
                            newsBoxVisible = false;
                        }
                        tweetBox.innerHTML = "";
                        tweetBox.style.left = `${x + 100}px`;
                        tweetBox.style.top = `${y - tweetBox.offsetHeight - 15}px`;
                        tweetData.forEach(tweet => {
                            const tweetTime = Math.floor(new Date(tweet.timestamp).getTime()/1000);
                            // check if the mouse's time match with the tweet's time from each tweet
                            // if yes, put text and show tweetBox, if no just skip
                            if(isSameDate(clickedTime, tweetTime)){ 
                                // console.log(tweet.username);
                                tweetBox.innerHTML += `
                                <div class="tweet">
                                    <img src="${tweet.profile}" style="width:30px; height:30px; border-radius:50%;" onerror="this.onerror=null; this.src='default-profile.png';"/>
                                    <b>@${tweet.username}</b><br><br>
                                    ${tweet.text}<br><br>
                                    <small>${tweet.timestamp}</small>
                                    <hr>
                                </div>
                            `;
                                tweetBox.style.display = "block";
                                tweetBoxVisible = true;
                            }
                        });
                        
                       
                        // hideTimeout = setTimeout(() => {
                        //     tweetBox.style.display = "none";
                        //     tweetBoxVisible = false;
                        // }, 10000); // 5000 milliseconds = 5 seconds
                    }
                // }
            });
        }
 
        //HERE is to fetch the old news and set the markers including trump/btc price/other events
        //need to add importantDate as param if its called by fetchEvent(); no need if called by loadChart()
        async function fetchNew(chartData){
            let allNewsData = [];
            console.log(time);
            //http://localhost:3000/news-data-old
            await fetch('https://chart-backend-0rxq.onrender.com/news-data-old')
            .then(res => res.json())
            .then(data => {
                // console.log("All Combined News Data:", data);
                let allNewsData = data;

                let importantEvents = [];
                const latestCandle = chartData[chartData.length - 1];
                // const markerTime = new Date(latestCandle.time * 1000).toISOString().split('T')[0];
                const markerTime = latestCandle.time; 
                
                if(chartData){
                    //HERE is to set the initial markers - for now no use
                    let initialMarkers = [{
                                time: '2024-11-05', // Ensure this matches data format
                                position: 'aboveBar', 
                                color: '#f74d4d', 
                                shape: 'circle', 
                                text: 'Trump Election', 
                                size:2
                            },
                            {
                                time: markerTime, 
                                position: 'belowBar', 
                                color: '#cc5118', // Marker color
                                shape: 'arrowUp', 
                                text: 'BTC Closing Price($)', 
                                size:2
                            }
                        ];
                        // console.log(markerTime);
                    if (latestCandle) {
                        // setMarkers(initialMarkers);
                        // console.log(markerTime);
                    } else {
                        console.error('latestCandle is undefined or null');
                    }
                
                    

                    if (allNewsData) {
                        try {
                            // Check if `feed` exists and is an array
                            if (allNewsData && Array.isArray(allNewsData)) {
                                // Example filter for important events
                                const keywords = [
                                    "inflation", "interest rate", "GDP", "recession", "subsidies", 
                                    "stimulus", "default", "bankruptcy", "merger", "acquisition", "bitcoin falls"
                                ];
                                allNewsData = allNewsData.filter(item => item && item.title);
                                // console.log(allNewsData);

                                // Filter news articles based on the keywords defined
                                importantEvents = allNewsData.filter(article => {
                                    return keywords.some(keyword => 
                                        article.title.toLowerCase().includes(keyword)
                                    );
                                });
                                console.log(importantEvents);
                                const chartMarkers = [];          
                                //group articles based on published date                 
                                const groupedArticles1 = importantEvents.reduce((acc, article) => {
                                    // Extract the date (ignore time)
                                    const date = new Date(article.publishedAt).toISOString().split("T")[0];
                                                        
                                    // If the date does not exist in the accumulator, create an empty array for it
                                    if (!acc[date]) {
                                        acc[date] = [];
                                    }

                                                    // Add the article to the respective date group
                                    acc[date].push(article);
                                                        
                                    return acc;
                                }, {});
                                console.log(groupedArticles1);

                                // create markers for each date
                                Object.keys(groupedArticles1).forEach(date => {
                                    const articles = groupedArticles1[date];
                                    const d = new Date(date);
                                    let markertime;
                                    if (time === '1d') {
                                        // Use exact date
                                        markertime = date;
                                    } else if (time === '1w') {
                                        // Align to start of the week (Sunday or Monday depending on your chart)
                                        const day = d.getDay(); // 0 = Sunday
                                        const diff = d.getDate() - day;
                                        d.setDate(diff);
                                        d.setHours(0, 0, 0, 0);
                                        markertime = Math.floor(d.getTime() / 1000);
                                    } else {
                                        markertime = date;
                                    }
                                    // Create a marker for each day (you can adjust this based on your charting library)
                                    chartMarkers.push({
                                        time: markertime,
                                        position: "aboveBar",
                                        color: '#f74d4d',
                                        shape: "circle",
                                        text: "News Update",
                                        size:2 
                                    });
                                });

                                setMarkers(chartMarkers); 
                                
                                newsBoxVisible = false;
                                // chart.subscribeClick(function (param) {
                                //     if (!param || !param.time) return;
                                    
                                //     const clickedTime = param.time;
                                //     const clickedDate = new Date(clickedTime * 1000);  // Keep it as a Date object
                                //     console.log("Clicked Date Object:", clickedDate);

                                //     const formattedDate = `${clickedDate.getFullYear()}-${String(clickedDate.getMonth() + 1).padStart(2, '0')}-${String(clickedDate.getDate()).padStart(2, '0')}`; // Format it only when needed
                                //     console.log("Clicked Date String:", formattedDate);
                                    
                                //     // Check if there's any article for this clicked date
                                //     articles = groupedArticles1[formattedDate];  // Ensure this matches the format in groupedArticles
                                //     console.log(articles);
                                //     // Check if articles exist for the clicked date
                                //     if (articles && articles.length > 0) {
                                //         const x = param.point.x;
                                //         const y = param.point.y;
                                        
                                //         // Display the articles if available
                                //         if (newsBoxVisible) {
                                //             newBox.style.display = "none";
                                //             newsBoxVisible = false;
                                //         }else{
                                            
                                //             if(tweetBoxVisible){
                                //                 tweetBox.style.display = "none";
                                //                 tweetBoxVisible = false;
                                //             }

                                //             newBox.innerHTML = ""; // Clear previous content
                                //             newBox.style.left = `${x + 100}px`;
                                //             newBox.style.top = `${y - newBox.offsetHeight - 15}px`;
                                            
                                //             articles.forEach(article => {
                                //                 newBox.innerHTML += `
                                //                     <div class="news-article">
                                //                         <b>${article.title}</b><br>
                                //                         <small>${article.publishedAt}</small>
                                //                         <small><a href = "${article.url}">${article.url}</a></small><br><br>
                                //                         <hr>
                                //                     </div>
                                //                 `;
                                //             });

                                //             newBox.style.display = "block";
                                //             newsBoxVisible = true;
                                //         }
                                //     } else {
                                //         console.log("No articles found for date:", formattedDate);
                                //     }
                                // });

                                
                                //iE = w/o taking the fund rate
                                //eD = take event start with date based on fund rate
                                //HERE is to set the markers of the events filtered
                                
                                chart.subscribeClick(function (param) {
                                    if (!param || !param.time) return;

                                    const clickedTime = param.time;
                                    const clickedDate = new Date(clickedTime * 1000);

                                    console.log("Clicked Date Object:", clickedDate);
                                    const articlesToShow = [];

                                    // Loop through all groupedArticles1 to check within time ranges
                                    for (const dateKey in groupedArticles1) {
                                        const articleDate = new Date(dateKey);  // Each key is in YYYY-MM-DD
                                        const articleTimestamp = articleDate.getTime();
                                        const clickedTimestamp = clickedDate.getTime();

                                        let match = false;

                                        if (time === '1d') {
                                            // Daily â€” exact date match
                                            match = clickedDate.toDateString() === articleDate.toDateString();
                                        } else if (time === '1w') {
                                            // Weekly â€” compare if in the same week
                                            const clickedWeekStart = getStartOfWeek(clickedDate);
                                            const articleWeekStart = getStartOfWeek(articleDate);
                                            match = clickedWeekStart.getTime() === articleWeekStart.getTime();
                                        } else {
                                            match = clickedDate.toDateString() === articleDate.toDateString();
                                        }
                                            // } else if (time === '1M') {
                                        //     // Monthly â€” compare year and month
                                        //     match = clickedDate.getFullYear() === articleDate.getFullYear() &&
                                        //             clickedDate.getMonth() === articleDate.getMonth();
                                        // }

                                        if (match) {
                                            articlesToShow.push(...groupedArticles1[dateKey]);
                                        }
                                        console.log(articlesToShow);
                                    }

                                    if (articlesToShow.length > 0) {
                                        const x = param.point.x;
                                        const y = param.point.y;

                                        if (newsBoxVisible) {
                                            newBox.style.display = "none";
                                            newsBoxVisible = false;
                                        } else {
                                            if (tweetBoxVisible) {
                                                tweetBox.style.display = "none";
                                                tweetBoxVisible = false;
                                            }

                                            newBox.innerHTML = ""; // Clear previous content
                                            newBox.style.left = `${x + 100}px`;
                                            newBox.style.top = `${y - newBox.offsetHeight - 15}px`;

                                            articlesToShow.forEach(article => {
                                                newBox.innerHTML += `
                                                    <div class="news-article">
                                                        <b>${article.title}</b><br>
                                                        <small>${article.publishedAt}</small>
                                                        <small><a href="${article.url}">${article.url}</a></small><br><br>
                                                        <hr>
                                                    </div>
                                                `;
                                            });

                                            newBox.style.display = "block";
                                            newsBoxVisible = true;
                                        }
                                    } else {
                                        console.log("No articles found for the selected timeframe.");
                                    }
                                
                                });
                                
                                
                                const newMarkers = importantEvents.map(event => {
                                    let rawDate = event.publishedAt || ""; // Get time_published safely
                                    let formattedDate = "";
                                    // console.log(rawDate);
                                    if (rawDate) {
                                        try {
                                            // Convert ISO 8601 timestamp to YYYY-MM-DD format
                                            let dateObj = new Date(rawDate);
                                            formattedDate = dateObj.toISOString().split("T")[0]; // Extract YYYY-MM-DD
                                            
                                        } catch (error) {
                                            console.warn(`Invalid date format detected: ${rawDate}, using fallback.`);
                                            formattedDate = "2024-01-01"; // Fallback date
                                        }
                                    } else {
                                        console.warn(`Missing date for event: ${event.title}`);
                                        formattedDate = "2024-01-01"; // Fallback date
                                    }

                                    return {
                                        time: formattedDate,
                                        position: "aboveBar",
                                        color: '#f74d4d',
                                        shape: "circle",
                                        text: event.title,
                                        size:2
                                    };
                                
                                });
                                // setMarkers(newMarkers);                   
                            } else {
                                console.error("âš ï¸ ERROR: `newsData.feed` is missing or not an array. Full object:", allNewsData);
                            }
                            } catch (error) {
                                console.error("âš ï¸ ERROR: Failed to parse news data:", error);
                            }
                            } else {
                                console.log("âš ï¸ No news data found in localStorage.");
                            }
                    
                } 
            })
            .catch(err => console.error("Failed to fetch news:", err));
        }
        function getStartOfWeek(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day;
            return new Date(d.setDate(diff));
        }

        //HERE is to fetch the M2 data using backend with federal reserve API
        async function fetchM2() {
            const API_URL = "https://chart-backend-0rxq.onrender.com/m2-data"; // Fetch from local server
            //http://localhost:3000/m2-data
            
            try {
                let response = await fetch(API_URL);
                let data = await response.json();
                let observations = data.observations;
                let m2Data = observations.map(d => ({
                    time: d.date,  // Ensure format is YYYY-MM-DD
                    value: parseFloat(d.value)
                }));
                //Add M2 Line Series (Left Axis)
                m2Series = chart.addLineSeries({
                    color: '#d19a02', 
                    lineWidth: 2,
                    priceScaleId: 'left',
                    
                });

               m2Series.setData(m2Data); // Update M2 series in LightweightCharts
               if (m2Data.length > 0) {
                    let latestM2 = m2Data[m2Data.length - 1]; // Get the latest data point
                    console.log("im here", m2Series);
                    m2Series.setMarkers([
                        {
                            time: latestM2.time,  // Ensure this matches the format in setData()
                            position: 'aboveBar', // Position marker above the data point
                            color: '#d19a02',     // Marker color
                            shape: 'arrowDown',   // Shape type
                            text: `M2: $${latestM2.value} Billion`, // Display the value
                            size: 2,
                            textFontSize: 40
                        }
                    ]);
                }
            } catch (error) {
                console.error("Error fetching M2 data:", error);

            }
        }


        //HERE is to fetch the sentiment data from santiment
        // calculate the sentiment ratio - now no use
        function fetchMaxSentData(timeframe){
            const sentNeg = JSON.parse(localStorage.getItem('sentNeg'));
            const sentPos = JSON.parse(localStorage.getItem('sentPos'));
            // console.log(sentNeg);
            // console.log(sentPos);
            const combinedSentimentData = [];
            sentPos.sentiment_positive.forEach((posItem, index) => {
                const negItem = sentNeg.sentiment_negative[index];
                console.log(posItem.value, negItem.value)
                // Combine the positive and negative sentiment data into one object
                if (posItem.datetime === negItem?.datetime){
                    const sentimentRatio = negItem.value !== 0 ? posItem.value / negItem.value : null;
                    if(sentimentRatio != null){
                        combinedSentimentData.push({
                        datetime: posItem.datetime, // Date from the positive sentiment data
                        value: sentimentRatio, // Positive sentiment value
                       });
                    }
                    // if(sentimentRatio<1){
                    //     console.log(sentimentRatio);
                    // }
                }
                    
            });

            const stepData1 = combinedSentimentData.map(item => ({
                time: new Date(item.datetime).getTime() / 1000, // Convert datetime to Unix timestamp (seconds)
                value: item.value
            }));

            
            const stepData = [];
            for (let i = 0; i < combinedSentimentData.length; i++) {
                stepData.push({
                    time: new Date(combinedSentimentData[i].datetime).getTime() / 1000,
                    value: combinedSentimentData[i].value
                });

                if (i < combinedSentimentData.length - 1) {
                    stepData.push({
                        time: new Date(combinedSentimentData[i + 1].datetime).getTime() / 1000,
                        value: combinedSentimentData[i].value
                    });
                }
            }
            
            stepSeries = chart.addLineSeries({
                priceScaleId: 'left',
                // crosshairMarkerVisible: true,
                color: "#b08d04",
                lineWidth: 1,
                zIndex: "2000"
            });

            
           
            console.log("Line 175");
            stepSeries.setData(stepData1);
            
        }

        // fetching then plotting the sentiment data
        // now no use
        async function fetchSentimentData() {
            try {
                const combinedSentimentData = [];
                // const response = await fetch('http://localhost:3000/sentiment-data');
                // const data = await response.json();
                // localStorage.setItem('sentNeg', JSON.stringify(data));
                //sentNeg = interval-1d
                //sentNegMax = aggregation-MAX
                const sentNeg = JSON.parse(localStorage.getItem('sentNeg'));
                const sentPos = JSON.parse(localStorage.getItem('sentPos'));
                if (sentPos && Array.isArray(sentPos.sentiment_positive)) {
                    // Loop through the array to extract the 'value' for each item
                    sentPos.sentiment_positive.forEach((posItem, index) => {
                        const negItem = sentNeg.sentiment_negative[index];
                        
                        // Combine the positive and negative sentiment data into one object
                        if (posItem.datetime === negItem?.datetime){
                            combinedSentimentData.push({
                                datetime: posItem.datetime, // Date from the positive sentiment data
                                sentimentPositive: posItem.value, // Positive sentiment value
                                sentimentNegative: negItem ? negItem.value : 0 // Negative sentiment value, with 0 as fallback
                            });
                        }
                        // console.log(posItem.datetime, posItem.value, negItem.value);
                    });
                    // console.log(combinedSentimentData);
                    drawSentiment(combinedSentimentData);
                } else {
                    console.log("No valid sentiment data found.");
                }
                // // Add sentiment data to the chart
                // sentimentSeries.setData(sentimentData);
                // if(sentimentSeries){
                //     // console.log("Im here");
                //     let latest = sentimentData[sentimentData.length - 1];
                //     sentimentSeries.setMarkers([
                //         {
                //             time: latest.time,  // Ensure this matches the format in setData()
                //             position: 'aboveBar', // Position marker above the data point
                //             color: '#1E90FF',     // Marker color
                //             shape: 'arrowDown',   // Shape type
                //             text: `Social Volume: ${latest.value}`, // Display the value
                //             size: 2,
                //             textFontSize: 40
                //         }
                //     ]);
                // }

            } catch (error) {
                console.error('Error fetching sentiment data:', error);
            }
        }

        // draw sentiment histogram that shows the total post 
        function toggleSentimentLine() {
            const sentimentCheckbox = document.getElementById('sent-checkbox');
            if (sentimentCheckbox.checked) {
                // If the checkbox is checked, draw the sentiment line
                fetchSentimentData();
            } else {
                // If the checkbox is unchecked, remove the sentiment line
                if (sentimentSeries) {
                    // Remove the sentiment line series if it exists
                    chart.removeSeries(sentimentSeries);
                    sentimentSeries = null;
                }
            }
        }
       
        function drawSentiment(sentimentData) {
            const sentimentBars = [];

            sentimentData.forEach(item => {
                const time = item.datetime;

                const positive = item.sentimentPositive;
                const negative = item.sentimentNegative;

                const totalVolume = positive + negative;

                const isPositiveDominate = positive > negative;
                const color = isPositiveDominate 
                    ? 'rgba(75, 192, 192, 0.8)'    // Green for bullish
                    : 'rgba(255, 99, 132, 0.8)';   // Red for bearish

                if(positive==negative){
                    console.log("Yes");
                }
                sentimentBars.push({
                    time,
                    value: totalVolume,
                    color
                });
            });
            sentimentSeries = chart.addHistogramSeries({
                lineWidth: 2,
                priceScaleId: 'left'  // You can use the left axis, or create a separate axis for sentiment
            });
            // sentimentSeries.applyOptions({
            //     priceScaleId: ''
            // });
            // console.log(sentimentSeries);
            sentimentSeries.applyOptions({
                priceScaleId: '' // This effectively removes the Y-axis for this series
            });
            sentimentSeries.setData(sentimentBars);
            // console.log(sentimentSeries);
        }

        //HERE is to fetch the federal fund rate to determine whether at that day spikes
        //now didn't use it
        async function fetchEvent(chartData) {
            const API_URL = "https://chart-backend-0rxq.onrender.com/event-data"; // Fetch from local server

            try {
                let response = await fetch(API_URL);
                let data = await response.json();
                // console.log(data);
            
                let observations = data.observations;
                let importantDate = [];

                //HERE is to calculate the changes of the rate
                for (let i = 1; i < observations.length; i++) {
                    let prevRate = parseFloat(observations[i - 1].value);
                    let currRate = parseFloat(observations[i].value);
                    let date = observations[i].date;

                    let change = (currRate - prevRate).toFixed(2);

                    //HERE is to calculate the changes of the rate
                    //if >= +-0.5, its consider huge and can push the date 
                    if (Math.abs(change) >= 0.5) { // Detect large rate changes
                        importantDate.push(date);
                        // console.log(date, change);
                    }
                    
                }
                //HERE is to fetch the news on the date pushed
                fetchNew(chartData, importantDate);
               
            } catch (error) {
                    console.error("Error fetching event data:", error);
                }
            
        }

        // fetching news - no use for now
        async function fetchMacroData() {
            const API_URL = "http://localhost:3000/truf-news"; // Fetch from local server

            try {
                let response = await fetch(API_URL);
                let data = await response.json();
                console.log(data);
            } catch (error) {
                console.error("Error fetching Macro data:", error);
            }
        }
        

        // ** TECHNICAL INDICATORS ** //
        
        function calculateIchimoku(data) {
            let result = {
                tenkanSen: [],
                kijunSen: [],
                senkouSpanA: [],
                senkouSpanB: [],
                chikouSpan: []
            };

            const interval = data[1].time - data[0].time; // e.g., 86400 for daily

            for (let i = 0; i < data.length; i++) {
                // Tenkan-sen: 9-period
                if (i >= 8) {
                    const slice = data.slice(i - 8, i + 1);
                    const high = Math.max(...slice.map(d => d.high));
                    const low = Math.min(...slice.map(d => d.low));
                    const tenkan = {
                        time: data[i].time,
                        value: (high + low) / 2
                    };
                    result.tenkanSen[i] = tenkan;
                    // console.log(result.tenkanSen[i])
                } 
                

                // Kijun-sen: 26-period
                if (i >= 26) {
                    const slice = data.slice(i - 26, i + 1);
                    const high = Math.max(...slice.map(d => d.high));
                    const low = Math.min(...slice.map(d => d.low));
                    const kijun = {
                        time: data[i].time,
                        value: (high + low) / 2
                    };
                    result.kijunSen[i] = kijun;
                    // console.log(result.kijunSen[i]);
                } 

                // Senkou Span A: (Tenkan + Kijun) / 2, plotted 26 periods ahead
                if (i >= 26) {
                    const tenkan = result.tenkanSen[i]?.value ?? null;
                    const kijun = result.kijunSen[i]?.value ?? null;
                    // console.log(tenkan, kijun);
                    
                    if (tenkan !== null && kijun !== null) {
                        const value = (tenkan+kijun) / 2;
                        const futureTime = data[i].time + (26 * interval);
                        const spanA = {
                            time: futureTime,
                            value: value
                        }
                        result.senkouSpanA[i+26] = spanA;
                    }

                }

                // Senkou Span B: 52-period high/low average, plotted 26 periods ahead
                if (i >= 51) {
                    const futureTime = data[i].time + (26 * interval);
                    const slice = data.slice(i - 51, i + 1);
                    const high = Math.max(...slice.map(d => d.high));
                    const low = Math.min(...slice.map(d => d.low));
                    const value = (high + low) / 2;
                    const spanB = {
                        time: futureTime,
                        value: value
                    }
                    result.senkouSpanB[i + 26] = spanB;
                }

                // // Chikou Span: close price, plotted 26 periods back
                if (i >= 26) {
                    const chikou = {
                        value: data[i].close,
                        time: data[i-26].time
                    }
                    result.chikouSpan[i - 26] = chikou;

                }
            }
            console.log(result);
            

            // tenkansenSeries = chart.addLineSeries({ color: '#71c752', lineWidth: 2 });
            // kijunsenSeries = chart.addLineSeries({ color: '#2f4a25', lineWidth: 2 });
            // spanASeries = chart.addLineSeries({ color: '#339660', lineWidth: 2 });
            // spanBSeries = chart.addLineSeries({ color: '#0ce8aa', lineWidth: 2 });
            // chikouSeries = chart.addLineSeries({ color: '#149ea6', lineWidth: 2 });
            // console.log(tenkansenSeries);
            result.tenkanSen = result.tenkanSen.filter(p => p !== undefined);
            result.kijunSen = result.kijunSen.filter(p => p !== undefined);
            result.senkouSpanA = result.senkouSpanA.filter(p => p !== undefined);
            result.senkouSpanB = result.senkouSpanB.filter(p => p !== undefined);
            result.chikouSpan = result.chikouSpan.filter(p => p !== undefined);

            return result;
        }

        function createIchimokuCheckboxes(chartData) {
            const ichiContainer = document.getElementById("ichimoku-options");
            ichiContainer.innerHTML = ""; // Clear existing checkboxes

            const ichimokuLine = ["Tenkansen", "Kijunsen", "Senkou Span A", "Senkou Span B", "Chikou Span"]; 

            const details = document.createElement("details");
            const summary = document.createElement("summary");
            summary.innerText = "Ichimoku Analysis";
            details.appendChild(summary);

            const checkboxContainer = document.createElement("div");
            checkboxContainer.style.display = "flex";
            checkboxContainer.style.flexDirection = "column";
            checkboxContainer.style.padding = "8px";

            ichimokuLine.forEach(period => {
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.id = `ichimoku-${period}`;
                checkbox.value = period;
                //HERE is to call the function to draw lines
                checkbox.addEventListener("change", function () {
                    toggleIchimoku(period, this.checked, chartData);
                });

                const label = document.createElement("label");
                label.htmlFor = `ichimoku-${period}`;
                label.innerText = `${period}`;

                const div = document.createElement("div");
                div.style.display = "flex";
                div.style.alignItems = "center";
                div.style.gap = "5px";

                div.appendChild(checkbox);
                div.appendChild(label);
                checkboxContainer.appendChild(div);
            });

            details.appendChild(checkboxContainer);
            ichiContainer.appendChild(details);
        }

        function toggleIchimoku(period, checked, chartData) {
            const ichiColors = {
                "Tenkansen": '#71c752',  
                "Kijunsen": '#2f4a25',  
                "Senkou Span A": '#339660', 
                "Senkou Span B": '#0ce8aa', 
                "Chikou Span": '#149ea6'
            };
            // const color = ichiColors[period];
            if (checked) {
                if (!ichimokuLine[period]) {
                    // console.log(period);
                    if(period == "Senkou Span A" || period == "Senkou Span B"){
                        ichimokuLine[period] = chart.addLineSeries({
                            color: ichiColors[period], 
                            lineWidth: 2, 
                            lineStyle: 0 // Solid Line
                        });
                    }else{
                        ichimokuLine[period] = chart.addLineSeries({
                            color: ichiColors[period], 
                            lineWidth: 2, 
                            lineStyle: 2 // Dashed Line
                        });
                    }

                    
                }
                //HERE is to call the function for calculation
                const ichimoku = calculateIchimoku(chartData);
                
                const keyMap = {
                    "Tenkansen": "tenkanSen",
                    "Kijunsen": "kijunSen",
                    "Senkou Span A": "senkouSpanA",
                    "Senkou Span B": "senkouSpanB",
                    "Chikou Span": "chikouSpan"
                };
                const seriesData = ichimoku[keyMap[period]];
                console.log(seriesData);
                ichimokuLine[period].setData(seriesData);
            } else {
                if (ichimokuLine[period]) {
                    chart.removeSeries(ichimokuLine[period]);
                    delete ichimokuLine[period];
                    // commentaries = null;
                }
                
            }
        }
        // supertrend - accuracy might need double confirm
        // no use now

        async function fetchSupertrend() {
            // Clear old Supertrend series

            const API_URL = "http://localhost:5000/supertrend"; // Fetch from local server
            
            try {
                let response = await fetch(API_URL);
                let data = await response.json();
                console.log(supertrendSeries);
                const upTrend = [];
                const downTrend = [];
                
                // const supertrendSegments = [];
                let currentSegment = [];
                let isUptrend = null;

                for (let i = 0; i < data.length; i++) {
                    const time = data[i].timestamp / 1000;
                    const value = data[i]["SUPERT_10_3.0"];
                    const direction = data[i]["SUPERTd_10_3.0"];

                    if (direction === 1 || direction === -1) {
                        const up = direction === 1;
                        if (isUptrend !== up) {
                            if (currentSegment.length) {
                                supertrendSegments.push({
                                    data: currentSegment,
                                    color: isUptrend ? 'green' : 'red'
                                });
                                currentSegment = [];
                            }
                            isUptrend = up;
                        }
                        currentSegment.push({ time, value });
                    }
                }

                // Push last segment
                if (currentSegment.length) {
                    supertrendSegments.push({
                        data: currentSegment,
                        color: isUptrend ? 'green' : 'red'
                    });
                }
                // console.log(supertrendSegments);
                // Render each segment as its own line series
                supertrendSegments.forEach(segment => {
                    const series = chart.addLineSeries({
                        color: segment.color,
                        lineWidth: 2,
                        lastValueVisible: false,
                        priceLineVisible: false,
                        lineStyle: 2

                    });
                    series.setData(segment.data);
                    supertrendSeries.push(series);
                });


            } catch (error) {
                console.log("Error fetching data", error);
            }
        }

        async function fetchSupertrend4h(){

            try {
                let response = await fetch("http://localhost:5000/supertrend4h");
                let data = await response.json();
                const upTrend = [];
                const downTrend = [];
                console.log(supertrendSeries);
                let currentSegment = [];
                let isUptrend = null;

                for (let i = 0; i < data.length; i++) {
                    const time = data[i].timestamp / 1000;
                    const value = data[i]["SUPERT_10_3.0"];
                    const direction = data[i]["SUPERTd_10_3.0"];

                    if (direction === 1 || direction === -1) {
                        const up = direction === 1;
                        if (isUptrend !== up) {
                            if (currentSegment.length) {
                                supertrendSegments.push({
                                    data: currentSegment,
                                    color: isUptrend ? 'green' : 'red'
                                });
                                currentSegment = [];
                            }
                            isUptrend = up;
                        }
                        currentSegment.push({ time, value });
                    }
                }

                // Push last segment
                if (currentSegment.length) {
                    supertrendSegments.push({
                        data: currentSegment,
                        color: isUptrend ? 'green' : 'red'
                    });
                }
                // console.log(supertrendSegments);
                // Render each segment as its own line series
                supertrendSegments.forEach(segment => {
                    const series = chart.addLineSeries({
                        color: segment.color,
                        lineWidth: 2,
                        lastValueVisible: false,
                        priceLineVisible: false,
                        lineStyle: 2

                    });
                    series.setData(segment.data);
                    supertrendSeries.push(series);
                });


            } catch (error) {
                console.log("Error fetching data", error);
            }
        }

        let count = 0;
        async function fetchSupertrend1w(){
            count+=1;
            console.log(count);
            try {
                let response = await fetch("http://localhost:5000/supertrend1w");
                let data = await response.json();
                console.log(supertrendSeries);
                const upTrend = [];
                const downTrend = [];
               
                let currentSegment = [];
                let isUptrend = null;

                for (let i = 0; i < data.length; i++) {
                    const time = data[i].timestamp / 1000;
                    const value = data[i]["SUPERT_10_3.0"];
                    const direction = data[i]["SUPERTd_10_3.0"];

                    if (direction === 1 || direction === -1) {
                        const up = direction === 1;
                        if (isUptrend !== up) {
                            if (currentSegment.length) {
                                supertrendSegments.push({
                                    data: currentSegment,
                                    color: isUptrend ? 'green' : 'red'
                                });
                                currentSegment = [];
                            }
                            isUptrend = up;
                        }
                        currentSegment.push({ time, value });
                    }
                }

                // Push last segment
                if (currentSegment.length) {
                    supertrendSegments.push({
                        data: currentSegment,
                        color: isUptrend ? 'green' : 'red'
                    });
                }
                // console.log(supertrendSegments);
                // Render each segment as its own line series
                supertrendSegments.forEach(segment => {
                    const series = chart.addLineSeries({
                        color: segment.color,
                        lineWidth: 2,
                        lastValueVisible: false,
                        priceLineVisible: false,
                        lineStyle: 2

                    });
                    series.setData(segment.data);
                    supertrendSeries.push(series);
                });


            } catch (error) {
                console.log("Error fetching data", error);
            }
        }

        function handleSupertrendToggle() {
            if ((document.getElementById('super-checkbox')).checked) {
                if (time === '1d') fetchSupertrend();
                else if (time === '4h') fetchSupertrend4h();
                else if (time === '1w') fetchSupertrend1w();
            } else {
                supertrendSeries.forEach(series => chart.removeSeries(series));
                supertrendSeries = [];
                supertrendSegments = [];
            }
        }


        function addSupertrend(data){
            
            const period = 3; // average true range
            const multiplier = 3; // adjust sensitivity
            let atrValue = 0;

            // Step 1: Calculate True Range (TR) and Average True Range (ATR)
            const tr = [];
            for (let i = 1; i < data.length; i++) {
                const currentHigh = data[i].high;
                const currentLow = data[i].low;
                const prevClose = data[i - 1].close;

                const highLow = currentHigh - currentLow;
                const highClose = Math.abs(currentHigh - prevClose);
                const lowClose = Math.abs(currentLow - prevClose);
                const trueRange = Math.max(highLow, highClose, lowClose);
                tr.push(trueRange);
            }

            // Step 2: Calculate ATR
            const atr = [];
            let sum = tr.slice(0, period).reduce((acc, val) => acc + val, 0);
            atr.push(sum / period);

            for (let i = period; i < tr.length; i++) {
                const prevATR = atr[atr.length - 1];
                const currentATR = (prevATR * (period - 1) + tr[i]) / period;
                atr.push(currentATR);
            }

            // Step 3: Calculate Upper and Lower Bands
            let baseUp = [];
            let baseDown = [];
            for (let i = 0; i < period - 1; i++) {
                baseUp.push(NaN);
                baseDown.push(NaN);
            }

            for (let i = period - 1; i < data.length; i++) {
                const atrIndex = i - (period - 1); // shift ATR into alignment
                const hl2 = (data[i].high + data[i].low) / 2;
                const expectedATR = atr[atrIndex];

                if (expectedATR !== undefined && !isNaN(expectedATR)) {
                    const upper = hl2 + (multiplier * expectedATR);
                    const lower = hl2 - (multiplier * expectedATR);
                    console.log(`i=${i}, atrIndex=${atrIndex}, HL2=${hl2.toFixed(2)}, ATR=${expectedATR.toFixed(2)}, baseUp=${upper.toFixed(2)}, baseDown=${lower.toFixed(2)}`);
                }
                if (atr[atrIndex] !== undefined && !isNaN(atr[atrIndex])) {
                    baseUp.push(hl2 + (multiplier * atr[atrIndex]));
                    baseDown.push(hl2 - (multiplier * atr[atrIndex]));
                } else {
                    baseUp.push(NaN);
                    baseDown.push(NaN);
                }
            }
            console.log("First ATR should align with data at i = period - 1");
            console.log("data index:", period - 1, "=> data[period-1].hl2 =", (data[period - 1].high + data[period - 1].low) / 2);
            console.log("atr[0] =", atr[0]);

            // Step 4: Calculate Final Upper and Lower Bands (fiUp, fiDown)
            let fiUp = [];
            let fiDown = [];
            let prevFiUp = 0;
            let prevFiDown = 0;
            for (let i = 0; i < data.length; i++) {
                if (isNaN(baseUp[i])) {
                    fiUp.push(NaN);
                } else if (i === 0) {
                    fiUp.push(baseUp[i]);
                    prevFiUp = baseUp[i];
                } else {
                    fiUp.push(baseUp[i] < prevFiUp || data[i - 1].close > prevFiUp ? baseUp[i] : prevFiUp);
                    prevFiUp = fiUp[i];
                }

                if (isNaN(baseDown[i])) {
                    fiDown.push(NaN);
                } else if (i === 0) {
                    fiDown.push(baseDown[i]);
                    prevFiDown = baseDown[i];
                } else {
                    fiDown.push(baseDown[i] > prevFiDown || data[i - 1].close < prevFiDown ? baseDown[i] : prevFiDown);
                    prevFiDown = fiDown[i];
                }
            }

            // Step 5: Calculate Supertrend
            let st = [];
            let prevSt = NaN;

            for (let i = 0; i < data.length; i++) {
                if (i < period) {
                    st.push(NaN);
                    continue;
                }

                let nowSt = 0;

                // If previous supertrend is not set
                if (isNaN(prevSt)) {
                    nowSt = data[i].close <= fiUp[i] ? fiUp[i] : fiDown[i];
                } else if (prevSt === fiUp[i - 1] && data[i].close <= fiUp[i]) {
                    nowSt = fiUp[i]; // Continue uptrend if close is below fiUp
                } else if (prevSt === fiUp[i - 1] && data[i].close > fiUp[i]) {
                    nowSt = fiDown[i]; // Switch to downtrend if close is above fiUp
                } else if (prevSt === fiDown[i - 1] && data[i].close >= fiDown[i]) {
                    nowSt = fiDown[i]; // Continue downtrend if close is above fiDown
                } else if (prevSt === fiDown[i - 1] && data[i].close < fiDown[i]) {
                    nowSt = fiUp[i]; // Switch to uptrend if close is below fiDown
                }

                st.push(nowSt);
                prevSt = nowSt;
            }


            // Step 6: Final Output and Alignment Check
            let up = [];
            let down = [];
            let indexUp = [];
            let indexDown = [];
            for (let i = 0; i < data.length; i++) {
                if (isNaN(st[i])) {
                    up.push(st[i]);
                    down.push(st[i]);
                    continue; // Skip further logic for NaN st[i]
                }

                if (data[i].close < st[i]) {
                    // Downtrend
                    down.push(st[i]);
                    up.push(NaN);
                    indexDown.push(i);
                } else {
                    // Uptrend
                    down.push(NaN);
                    up.push(st[i]);
                    indexUp.push(i);
                }

                console.log(`i=${i}, Close=${data[i].close}, fiUp=${fiUp[i]}, fiDown=${fiDown[i]}, st=${st[i]}, up=${up[i]}, down=${down[i]}`);
            }

            console.log(data.length, atr.length, baseUp.length, fiUp.length, st.length);


            // console.log(up);
            // console.log(down);
            // // Step 3: Calculate Supertrend
            // let supertrend = [];
            // let colors = [];
            // supertrend.push(upperBand[0]); // The first supertrend is the first upper band value
            // colors.push('green');
            // // console.log(supertrend);
            // for (let i = 1; i < data.length; i++) {
            //     const currentClose = data[i].close;
            //     const previousSupertrend = supertrend[i - 1];

            //     if (currentClose > previousSupertrend) {
            //         // If the close is above the previous Supertrend, set to upper band
            //         supertrend.push(Math.max(upperBand[i], previousSupertrend));
            //         colors.push('green');  // Bullish, use green
            //     } else {
            //         // If the close is below the previous Supertrend, set to lower band
            //         supertrend.push(Math.min(lowerBand[i], previousSupertrend));
            //         colors.push('red');  // Bearish, use red
            //     }
            // }

            // supertrendSeries = chart.addLineSeries({
            //     color: 'red', // Default color (it will be updated dynamically)
            //     lineWidth: 2
            // });
            
            // const supertrendData = supertrend.map((st, index) => {
            //     return {
            //         time: data[index].time,  // Human-readable date
            //         value: st                      // Supertrend value
            //     };
            // });
            // console.log(supertrendData);
            // supertrendSeries.setData(supertrendData);

            let isUptrend = null;
            let currentSegment = [];
            const supertrendSegments = [];

            // Loop through your data to build trend segments
            for (let i = 0; i < data.length; i++) {
                const time = data[i].time;
                const upValue = up[i];
                const downValue = down[i];

                if (!isNaN(upValue)) {
                    if (isUptrend !== true) {
                        if (currentSegment.length) {
                            supertrendSegments.push({
                                data: currentSegment,
                                color: isUptrend === false ? 'red' : 'gray'
                            });
                        }
                        currentSegment = [];
                        isUptrend = true;
                    }
                    currentSegment.push({ time: time, value: upValue });
                } else if (!isNaN(downValue)) {
                    if (isUptrend !== false) {
                        if (currentSegment.length) {
                            supertrendSegments.push({
                                data: currentSegment,
                                color: isUptrend === true ? 'green' : 'gray'
                            });
                        }
                        currentSegment = [];
                        isUptrend = false;
                    }
                    currentSegment.push({ time: time, value: downValue });
                } else {
                    // Break line if no valid value
                    if (currentSegment.length) {
                        supertrendSegments.push({
                            data: currentSegment,
                            color: isUptrend ? 'green' : 'red'
                        });
                        currentSegment = [];
                    }
                    isUptrend = null;
                }
            }

            // Push any remaining segment
            if (currentSegment.length) {
                supertrendSegments.push({
                    data: currentSegment,
                    color: isUptrend ? 'green' : 'red'
                });
            }

            // Now create line series for each segment
            // supertrendSegments.forEach(segment => {
            //     let lineSeries = chart.addLineSeries({
            //         color: segment.color,
            //         lineWidth: 2,
            //         priceLineVisible: false,
            //         lastValueVisible: false
            //     });
            //     lineSeries.setData(segment.data);
            // });

            return supertrendSegments;


        }
 
        // HERE is to create SMA checkboxes
        function createSMACheckboxes(chartData) {
            const smaContainer = document.getElementById("sma-options");
            smaContainer.innerHTML = ""; // Clear existing checkboxes

            const smaPeriods = [20, 50, 100, 200, 365]; // Common SMA periods

            const details = document.createElement("details");
            const summary = document.createElement("summary");
            summary.innerText = "SMA Periods";
            details.appendChild(summary);

            const checkboxContainer = document.createElement("div");
            checkboxContainer.style.display = "flex";
            checkboxContainer.style.flexDirection = "column";
            checkboxContainer.style.padding = "8px";

            smaPeriods.forEach(period => {
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.id = `sma-${period}`;
                checkbox.value = period;
                //HERE is to call the function to draw lines
                checkbox.addEventListener("change", function () {
                    toggleSMA(period, this.checked, chartData);
                });

                const label = document.createElement("label");
                label.htmlFor = `sma-${period}`;
                label.innerText = `SMA ${period}`;

                const div = document.createElement("div");
                div.style.display = "flex";
                div.style.alignItems = "center";
                div.style.gap = "5px";

                div.appendChild(checkbox);
                div.appendChild(label);
                checkboxContainer.appendChild(div);
            });

            details.appendChild(checkboxContainer);
            smaContainer.appendChild(details);
        }

        // HERE is to calculate SMA with different periods
        function calculateSMA(data, period) {
            let smaData = [];
            for (let i = period - 1; i < data.length; i++) { 
                let sum = 0;
                for (let j = 0; j < period; j++) { 
                    sum += data[i - j].close;
                }
                let avg = sum / period;
                smaData.push({ time: data[i].time, value: avg });
            }
            // console.log("period", period); //81 sma (100-19)
            return smaData;
        }

        // HERE is to draw SMA lines
        function toggleSMA(period, checked, chartData) {
            //different shades of blue for different periods
            const smaColors = {
                20: '#1e95e3',  
                50: '#227bb5',  
                100: '#22648f', 
                200: '#1c4763',
                365: '#102b3d'  
            };
            const color = smaColors[period];
            if (checked) {
                if (!smaLines[period]) {
                    // console.log(smaLines[period]);
                    
                    smaLines[period] = chart.addLineSeries({
                        color: color, 
                        lineWidth: 2, 
                        lineStyle: 0 // Solid Line
                    });
                }
                //HERE is to call the function for calculation
                const smaData = calculateSMA(chartData, period);
                
                if (period == 50) {
                    // console.log(smaData);
                    sma50 = smaData;                    
                } else if (period == 200) {
                    // console.log(smaData);
                    sma200 = smaData;
                    
                    // console.log(sma200);
                } else if(period == 365){
                    sma365 = smaData;
                    if(mvrvSeries)
                        detectMVRVandSMA();
                }
                if(sma50 && sma200){
                    commentaries = detectCross(sma50, sma200);
                }else{

                    commentaries = null;
                }
                // console.log(sma50);
                // console.log(sma200);
                smaLines[period].setData(smaData);
            } else {
                if(period == 50){
                    sma50 = [];
                }
                if(period == 200){
                    sma200 = [];
                    // signals = [];
                }
                if(period == 365){
                    sma365 = [];
                    signals = [];
                }
                if(sma50 && sma200){
                    commentaries = detectCross(sma50, sma200);
                }else{
                    commentaries = null;
                }
                if (smaLines[period]) {
                    chart.removeSeries(smaLines[period]);
                    delete smaLines[period];
                    // commentaries = null;
                }
                
            }

            // const remainingSMAs = Object.keys(smaLines);
            // if (remainingSMAs.length > 0) {
            //     updateLegend("SMA", 0, color);
            // } else {
            //     updateLegend("SMA", "None", color);
            // }
        }

        function detectCross(smaShort, smaLong){
            let commentaries = [];
            // console.log("Im here");
            for (let i = 1; i < smaShort.length; i++) {
                const shortPoint = smaShort[i];
                const prevShortPoint = smaShort[i - 1];
                const longIndex = smaLong.findIndex(p => p.time === shortPoint.time);
                const prevLongIndex = smaLong.findIndex(p => p.time === prevShortPoint.time);

                if (longIndex > 0 && prevLongIndex > 0) {
                    const prevShort = prevShortPoint.value;
                    const prevLong = smaLong[prevLongIndex].value;
                    const currShort = shortPoint.value;
                    const currLong = smaLong[longIndex].value;
                    // Golden Cross
                    if (prevShort < prevLong && currShort >= currLong) {
                        commentaries.push({
                            time: smaShort[i].time,
                            type: "golden",
                            text: "Golden Cross detected: Bullish momentum likely."
                        });
                    }

                    // Death Cross
                    if (prevShort > prevLong && currShort <= currLong) {
                        commentaries.push({
                            time: smaShort[i].time,
                            type: "death",
                            text: "Death Cross detected: Bearish trend may follow."
                        });
                    }
                }
            }

            return commentaries;
        }

        // HERE is to calculate EMA with different periods
        function calculateEMA(data, period) {
            let emaData = [];
            let multiplier = 2 / (period + 1); // Smoothing factor 2/21

            // Start with the first SMA as the initial EMA value
            let sum = 0;
            for (let i = 0; i < period; i++) {// i<50
                sum += data[i].close;
            }
            let prevEMA = sum / period;
            if (data[period - 1]) {
                // console.log("Im here");
                emaData.push({ time: data[period - 1].time, value: prevEMA });
            }

            // Calculate EMA for the rest
            for (let i = period; i < data.length; i++) {
                let ema = (data[i].close - prevEMA) * multiplier + prevEMA;
                emaData.push({ time: data[i].time, value: ema });
                prevEMA = ema;
            }
            return emaData;
        }

        // HERE is to calculate the BB with fixed(20) periods
        function calculateBollingerBands(data, period = 20, multiplier = 2) {
            let bands = [];
            for (let i = period - 1; i < data.length; i++) {
                let slice = data.slice(i - period + 1, i + 1); // Get last `period` values
                let sma = slice.reduce((sum, d) => sum + d.close, 0) / period;

                // Calculate standard deviation
                let variance = slice.reduce((sum, d) => sum + Math.pow(d.close - sma, 2), 0) / period;
                let stdDev = Math.sqrt(variance);

                let upperBand = sma + (stdDev * multiplier);
                let lowerBand = sma - (stdDev * multiplier);

                bands.push({ time: data[i].time, middle: sma, upper: upperBand, lower: lowerBand });

                // Check if BTC price crosses or touches the lower band
                if (data[i].close <= lowerBand) {
                    bbAlerts.push({ time: data[i].time, price: data[i].close, message: `Price ($${data[i].close}) touched or crossed the lower Bollinger Band!` });
                }
            }
            return bands;
        }

        // HERE is to remove the BB (3 series) when the checkbox is unchecked or when the chart is reset/switched
        function removeBollingerBands() {
            if (bollingerUpperSeries) {
                chart.removeSeries(bollingerUpperSeries);
                bollingerUpperSeries = null;
            }
            if (bollingerLowerSeries) {
                chart.removeSeries(bollingerLowerSeries);
                bollingerLowerSeries = null;
            }
            if (bollingerMiddleSeries) {
                chart.removeSeries(bollingerMiddleSeries);
                bollingerMiddleSeries = null;
            }
            bbAlerts = [];
        }

        //2nd HERE is to calculate the Fibonacci level with 7 level 
        function calculateFibonacciLevels(high, low) {
            return {
                0.0: high - (0.0 * (high - low)),
                0.236: high - (0.236 * (high - low)),
                0.382: high - (0.382 * (high - low)),
                0.5: high - (0.5 * (high - low)),
                0.618: high - (0.618 * (high - low)),
                0.786: high - (0.786 * (high - low)),
                1.0: high - (1.0 * (high - low)),
            };
        }

        //3rd HERE is to draw the Fibonacci lines when checkbox is checked
        //horizontal priceLine is used
        function drawFibonacci(level, value, checked) {
            if (checked) {
                if (!fibonacciLines[level]) {
                    fibonacciLines[level] = candleSeries.createPriceLine({
                        price: value,
                        color: '#edb90e', 
                        lineWidth: 1,
                        lineStyle: 2, // Dashed Line
                        axisLabelVisible: true, // Show label on the price axis
                        title: `Fib ${level}%` // Label for the Fibonacci level
                    });
                }
            } else {
                if (fibonacciLines[level]) {
                    candleSeries.removePriceLine(fibonacciLines[level]);
                    delete fibonacciLines[level];
                }
            }

            // Update legend based on remaining Fibonacci levels
            // const remainingLevels = Object.keys(fibonacciLines);
            // if (remainingLevels.length > 0) {
            //     updateLegend("fib", 0, "#edb90e");
            // } else {
            //     updateLegend("fib", "None", "#73c769");
            // }
        }

        //1st HERE is to create Fibonacci checkbox dynamically
        function createFibonacciCheckboxes(chartData) {
            const fibContainer = document.getElementById("fibonacci-options");
            fibContainer.innerHTML = ""; // Clear existing checkboxes

            const high = Math.max(...chartData.map(d => d.high));
            const low = Math.min(...chartData.map(d => d.low));
            //HERE is to call the function for calculation
            const fibLevels = calculateFibonacciLevels(high, low);

            // Create dropdown container
            const details = document.createElement("details");
            const summary = document.createElement("summary");
            summary.innerText = "Fibonacci Levels";
            
            details.appendChild(summary);

            const checkboxContainer = document.createElement("div");
            checkboxContainer.style.display = "flex";
            checkboxContainer.style.flexDirection = "column";
            checkboxContainer.style.padding = "8px";

            Object.entries(fibLevels)
            .sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]))
            .forEach(([level, value]) => {
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.id = `fib-${level}`;
                checkbox.value = level;
                //HERE is to call the function for drawing the lines
                checkbox.addEventListener("change", function () {
                    drawFibonacci(level, value, this.checked, chartData);
                });

                const label = document.createElement("label");
                label.htmlFor = `fib-${level}`;
                label.innerText = `Fib ${level}`;

                const div = document.createElement("div");
                div.style.display = "flex";
                div.style.alignItems = "center";
                div.style.gap = "5px";

                div.appendChild(checkbox);
                div.appendChild(label);
                checkboxContainer.appendChild(div);
            });

            details.appendChild(checkboxContainer);
            fibContainer.appendChild(details);
        }

        //HERE is to calculate RSI
        function calculateRSI(data, period = 14) {
            let gains = [];
            let losses = [];
            // Step 1: Compute gains & losses
            for (let i = 1; i < data.length; i++) {
                let change = data[i].close - data[i - 1].close;
                gains.push(change > 0 ? change : 0);
                losses.push(change < 0 ? Math.abs(change) : 0);
            }

            // Step 2: Compute initial average gain/loss
            let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
            let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;

            let rsi = [];

            // Step 3: Compute RSI for each period
            for (let i = period; i < gains.length; i++) {
                avgGain = (avgGain * (period - 1) + gains[i]) / period;
                avgLoss = (avgLoss * (period - 1) + losses[i]) / period;

                let rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                let rsiValue = 100 - (100 / (1 + rs));

                rsi.push({ time: data[i + 1].time, value: rsiValue });
            }

            return rsi;
        }

        function findPivots(data, isHigh = true, lookback = 3) {
            const pivots = [];
            for (let i = lookback; i < data.length - lookback; i++) { // if data = 20, i = 3 to 16
                let isPivot = true;
                for (let j = 1; j <= lookback; j++) { // j = 1, 2, 3
                    if (
                        (isHigh && data[i].value <= data[i - j].value) || // data[3] <= data[0 to 2]
                        (isHigh && data[i].value <= data[i + j].value) || // data[3] <= data[4 to 6]
                        (!isHigh && data[i].value >= data[i - j].value) || // data[3] >= data[0 to 2]
                        (!isHigh && data[i].value >= data[i + j].value) // data[3] = data[4 to 6]
                    ) {
                        isPivot = false;
                        break;
                    }else{
                        // console.log(data[i].value);
                    }
                }
                if (isPivot) {
                    pivots.push({ index: i, value: data[i].value, time: data[i].time });
                    // console.log(pivots);
                }
            }
            // console.log(pivots);
            return pivots;
        }

        function detectDivergence(pricePivots, rsiPivots, isBullish = true) {
            const divergences = [];

            for (let i = 1; i < pricePivots.length; i++) {
                const priceCurrent = pricePivots[i];
                const pricePrev = pricePivots[i - 1];

                const rsiCurrent = rsiPivots.find(r => r.time === priceCurrent.time);
                const rsiPrev = rsiPivots.find(r => r.time === pricePrev.time);
                // console.log(priceCurrent, pricePrev);
                // console.log(rsiCurrent, rsiPrev);
                if (rsiCurrent && rsiPrev) {
                    if (
                        isBullish &&
                        priceCurrent.value < pricePrev.value &&      // lower low in price
                        rsiCurrent.value > rsiPrev.value             // higher low in RSI
                    ) {
                        divergences.push({ time: priceCurrent.time, type: 'bullish' });
                    }

                    if (
                        !isBullish &&
                        priceCurrent.value > pricePrev.value &&      // higher high in price
                        rsiCurrent.value < rsiPrev.value             // lower high in RSI
                    ) {
                        divergences.push({ time: priceCurrent.time, type: 'bearish' });
                    }
                }
            }

            return divergences;
        }

        // ** Extra features : markers and borders ** //

        function clearAllIndicators() {
            const bbCheckbox = document.getElementById('bb-select');
            const rsiCheckbox = document.getElementById('rsi-checkbox');
            const sentCheckbox = document.getElementById('sent-checkbox');
            let smaSelect = document.getElementById('sma-select');
            let emaSelect = document.getElementById('ema-select');
            let analysisSelect = document.getElementById('analysis-select');
            let superSelect = document.getElementById('super-checkbox');
            // 1. remove EMA lines everytime the chart is switched
            emaSelect.value = ""; //clear the list for EMA
            if (emaSeries) { chart.removeSeries(emaSeries); emaSeries = null; }
               
            // 2. remove Fibonacci lines
            document.querySelectorAll('#fibonacci-options input[type="checkbox"]').forEach(
                cb => cb.checked = false);

            Object.values(fibonacciLines).forEach(series => {
                if(candleSeries){
                    candleSeries.removePriceLine(series);
                }
            });
            fibonacciLines = {}; 
                // console.log(candleSeries);
                //remove chart data
                
            // 3. remove SMA lines
            document.querySelectorAll('#sma-options input[type="checkbox"]').forEach(
                cb => cb.checked = false);

            Object.values(smaLines).forEach(series => {
                chart.removeSeries(series);
            });
            smaLines = {};
                // if (smaLines) { chart.removeSeries(smaLines); smaLines = null; }
                // console.log(Object.keys(smaLines).length === 0);
                // console.log(Object.keys(fibonacciLines).length === 0);
               
                // console.log(emaSeries == null);
            // 4. remove BB lines
            bbCheckbox.checked = false;
            removeBollingerBands();
            // 5. remove RSI
            rsiCheckbox.checked = false;
            if (rsiSeries) {
                rsiChart.removeSeries(rsiSeries);
                rsiSeries = null;
            }

            sentCheckbox.checked = false;
            if(sentimentSeries){
                removeSentimentLine();
            }
                // markers = [];

            // 6. remove ichimoku line and set checkbox to false
            document.querySelectorAll('#ichimoku-options input[type="checkbox"]').forEach(
                cb => cb.checked = false);

                
            Object.values(ichimokuLine).forEach(series => {
                chart.removeSeries(series);
            });
            ichimokuLine = {};

            // 7. remove mvrv lines
            if(mvrvSeries){
                chart.removeSeries(mvrvSeries);
                mvrvSeries = null;
            }

            // 8. clear tweetBox and newBox
            tweetBox.innerHTML = "";
            tweetData = [];
            newBox.innerHTML = "";
            tweetBox.style.display = "none";
            newBox.style.display = "none";


            // 9. clear m2
            analysisSelect.value = "";
            if(m2Series){
                chart.removeSeries(m2Series);
                m2Series = null;
            }

            // 10. clear supertrend series
            superSelect.checked = false;
            if (supertrendSeries && supertrendSeries.length) {
                supertrendSeries.forEach(series => {
                    chart.removeSeries(series);
                });
                supertrendSeries = [];          // Clear references to the series
            }

            supertrendSegments = [];            // Set to empty array, not null

            
        }


        function setMarkers(markerArray){
            markers = [...markers, ...markerArray];
            if(markers){
                // console.log(markers);
                candleSeries.setMarkers(markers);
            }
            markers.forEach(item => {
                // console.log(item.time);
            })

           
        }

        //HERE is to shorten the event title into suitable short label
        //now didn't use it
        function shortenEventLabel(title) {
            // Common financial and stock-related abbreviations
            const abbreviations = {
                "Federal Reserve": "Fed",
                "Interest Rate": "Rate",
                "Approval": "Approved",
                "Decision": "Dec.",
                "Announces": "",
                "Reports": "",
                "Earnings": "Earnings",
                "Bitcoin": "BTC",
                "Ethereum": "ETH",
                "Halving": "Halving",
                "Merger": "Merge",
                "Market Rally": "Rally",
                "Stock Crash": "Crash",
                "Inflation": "CPI"
            };

            // Split the title into words
            let words = title.split(" ");

            // Replace words with abbreviations where applicable
            let shortenedWords = words.map(word => abbreviations[word] || word);

            // Remove empty words and unnecessary conjunctions
            let filteredWords = shortenedWords.filter(word => word && !["the", "is", "on", "for", "to"].includes(word.toLowerCase()));

            // Join back into a shortened title
            return filteredWords.join(" ");
        }
        
        //HERE is to update the legend dynamically
        //now only for bollinger bands
        function updateLegend(indicator, period, color) {
           
            const legendContainer = document.getElementById("smaLegend"); // Use a general container for all legends
            // Check if the legend for this specific indicator already exists
            let existingLegend = document.getElementById(`legend-${indicator}`);
            let leg = document.getElementById(`${indicator}-select`);
            // console.log("line 101", leg);
            // console.log("line 102", indicator);
            let selectedText = null;
            if(indicator=="bb"){
                // console.log("bb");
                selectedText = leg.innerText;}
            // else if (indicator == "fib") {
            //     // console.log("fib");
            //     selectedText = getFibonacciLevel();
            //     // console.log(selectedText);
            // }else if (indicator == "SMA"){
            //     selectedText = getSMAPeriod();
            //     // console.log("SMA");
            // }
            // else{ //for ema and sma (single option)
            //     // console.log("Im else");
            //     selectedText = leg.options[leg.selectedIndex].innerText;
            //     // console.log("EMA");
            // }
            // console.log("line 108", selectedText);
           
            // if period == "None"
            if(isNaN(period)){
                if(existingLegend){
                    legendContainer.removeChild(existingLegend);
                }
                return;
            }
            if (existingLegend) {
                // Remove the existing legend for the same indicator before adding a new one
                legendContainer.removeChild(existingLegend);
            }
            //if 0 go here
            // Create a new legend item if it doesnâ€™t exist
            const legendItem = document.createElement("div");
            legendItem.id = `legend-${indicator}`;  // Unique ID for each legend
            legendItem.style.color = color;
            legendItem.style.fontSize = "14px";
            legendItem.style.fontWeight = "bold";
            if(indicator!="bb")
                legendItem.innerText = selectedText;
            else
                legendItem.innerText = "Bollinger Bands";
            // console.log("line 119",legendItem.id)
            // Append new legend item
            
            legendContainer.appendChild(legendItem);
            
            updateLegendBorder();
            
        }

        //HERE is to update the legend border dynamically
        function updateLegendBorder() {
            const legendContainer = document.getElementById("smaLegend");

            if (legendContainer.childElementCount === 0) {
                // If empty, no border
                legendContainer.style.border = "0px";
            } 
            else {
                // If has items, use solid border
                legendContainer.style.border = "2px solid #b3bab3";
            }
            
        }
        
        // compare the date of the tweet with the chart date
        function isSameDate(date1, date2) {
            // Ensure both date1 and date2 are in milliseconds
            const d1 = new Date(date1 * 1000);  // Convert to milliseconds if it's in seconds
            const d2 = new Date(date2 * 1000);  // Convert to milliseconds if it's in seconds
            // console.log(d1,d2);
            // Normalize to date-only (set time to 00:00:00.000)
            d1.setHours(0, 0, 0, 0);
            d2.setHours(0, 0, 0, 0);
            // console.log(d1,d2);
            // Compare the dates
            return d1.getTime() === d2.getTime();
        }

        async function loadChart(timeframe) {
            const binanceTimeframe = timeframe;
            document.getElementById("smaLegend").innerHTML = "";
            updateLegendBorder();
            time = timeframe;
            
            //clear chartData if there is any to ensure it contains the latest data
            chartData = [];
            // if using binanceAPI
            chartData = await fetchData(binanceTimeframe);
            // lineData = await fetchLineData(binanceTimeframe);
            // if using alphaVantage
            // chartData = await fetchData();
            // console.log("line 761", chartData);
            const bbCheckbox = document.getElementById('bb-select');
            const rsiCheckbox = document.getElementById('rsi-checkbox');
            const sentCheckbox = document.getElementById('sent-checkbox');
            let smaSelect = document.getElementById('sma-select');
            let emaSelect = document.getElementById('ema-select');
            let analysisSelect = document.getElementById('analysis-select');
            let superSelect = document.getElementById('super-checkbox');
            // console.log("Current timeframe:", timeframe);
    
            if (candleSeries!=null) {
                // console.log("Im not null");
                chart.removeSeries(candleSeries);
                // console.log(candleSeries);
                candleSeries = null;
            }
            
            if (chartData) {
                const latestCandle = chartData[chartData.length - 1];
                console.log("Loading chart for:", timeframe);
                // smaSelect.value = "";
                // Remove all the old series before adding a new one
                
                markers = [];

                clearAllIndicators();
                // toggleSentimentLine();  // This will either add or remove the line based on checkbox state
                // if(supertrendSeries){
                //     console.log("Im stseries");
                //     chart.removeSeries(supertrendSeries); 
                //     supertrendSeries = null;
                // }

                //if (rsiSeries) { chart.removeSeries(rsiSeries); rsiSeries = null; }
                
                // if (bollingerUpperSeries) chart.removeSeries(bollingerUpperSeries);
                // if (bollingerLowerSeries) { chart.removeSeries(bollingerLowerSeries); bollingerLowerSeries = null; }
                // if (bollingerMiddleSeries) { chart.removeSeries(bollingerMiddleSeries); bollingerMiddleSeries = null; }

                //HERE is to set the bitcoin data
                candleSeries = chart.addCandlestickSeries();
                candleSeries.setData(chartData);
                if(candleSeries!=null) {
                    // console.log(chartData);
                }
                // console.log(binanceTimeframe);
                // console.log(timeframe);
                
                //lineSeries.setData(lineData);
                //HERE is to fetch the federal fund rate then fetch the corresponding events (now didn't use)
                //then label the event in daily chart (but now just filter based on the keywords)
                fetchNew(chartData);
                // fetchMacroData();
                // await fetchMVRV();
                // setEvent(candleSeries);
                //HERE is to create fibonacci checkboxes then plot the lines
                createFibonacciCheckboxes(chartData);
                //HERE is to create SMA checkboxes then plot the lines
                createSMACheckboxes(chartData);
                // detectMVRVandSMA();
                createIchimokuCheckboxes(chartData);
                fetchTwitter();
                // const result = calculateIchimoku(chartData);
                // console.log(result);
                // Listen for changes in the checkbox to toggle sentiment line
                const sentimentCheckbox = document.getElementById('sent-checkbox');
                // sentimentCheckbox.addEventListener('change', toggleSentimentLine);
                // create a separate chart for RSI
                if (!rsiChart) {
                    rsiChart = LightweightCharts.createChart(document.getElementById('rsi-container'), {
                        width: document.getElementById('rsi-container').clientWidth,
                        height: 200,
                        layout: { backgroundColor: '#ffffff', textColor: '#000' },
                        grid: { vertLines: { color: '#eeeeee' }, horzLines: { color: '#eeeeee' } }
                    });
                }

                
                // fetchMacroData();
                emaSelect.addEventListener('change', function () {
                    if (emaSeries) chart.removeSeries(emaSeries);  // Remove old EMA before adding new one
                    const selectedPeriod = parseInt(this.value);
                    // console.log("Ema period", selectedPeriod);
                    // if (!selectedPeriod) return;  // If "None" is selected, do nothing
                    // updateLegend("ema", selectedPeriod, "#73c769"); 
                    
                    const emaData = calculateEMA(chartData, selectedPeriod);
                    emaSeries = chart.addLineSeries({ color: '#f58747', lineWidth: 2 });
                    emaSeries.setData(emaData);
                    //updateLegend("ema", selectedPeriod, "#73c769"); 
                });
                // add event listener for bb
                bbCheckbox.addEventListener('change', function () {
                    if (this.checked) {
                        const bollingerData = calculateBollingerBands(chartData, 20, 2);
                        if (!bollingerUpperSeries){
                            // Middle Band (SMA)
                            bollingerMiddleSeries = chart.addLineSeries({ color: '#7242a6', lineWidth: 2 , lineStyle: 2});
                            bollingerMiddleSeries.setData(bollingerData.map(d => ({ time: d.time, value: d.middle })));

                            // Upper Band
                            bollingerUpperSeries = chart.addLineSeries({ color: '#c474fc', lineWidth: 2 });
                            bollingerUpperSeries.setData(bollingerData.map(d => ({ time: d.time, value: d.upper })));

                            // Lower Band
                            bollingerLowerSeries = chart.addLineSeries({ color: '#c474fc', lineWidth: 2 });
                            bollingerLowerSeries.setData(bollingerData.map(d => ({ time: d.time, value: d.lower })));

                            updateLegend("bb", 0, "#8c50cc"); 
                        }
                    } 
                    else {
                        removeBollingerBands();
                        updateLegend("bb", "None", "#8c50cc"); 
                    }
                });

                analysisSelect.addEventListener('change', async function () {
                    if (m2Series) {
                        chart.removeSeries(m2Series);
                        m2Series = null;
                    }
                    if (mvrvSeries) {
                        chart.removeSeries(mvrvSeries);  
                        mvrvSeries = null;
                    }
                    
                    // console.log("Ema period", selectedPeriod);
                    if (!this.value) return;  // If "None" is selected, do nothing
                    switch (this.value) {
                        case "m2":
                            await fetchM2();
                            break;
                        case "mvrv":
                            await fetchMVRV();
                            break;
                        default:
                            // Optionally handle unknown values
                            console.warn("Unknown metric selected:", this.value);
                            break;
                    }
                });

                superSelect.addEventListener('change',handleSupertrendToggle);
                // add event listener for rsi
                rsiCheckbox.addEventListener('change', function () {
                    if (!rsiChart) return;
                    if (this.checked) {
                        if (rsiSeries) {
                            rsiChart.removeSeries(rsiSeries); // Remove previous RSI series
                        }
                        const rsiData = calculateRSI(chartData, 14);

                        rsiSeries = rsiChart.addLineSeries({
                            color: '#9467bd',
                            lineWidth: 2,
                        });

                        rsiSeries.setData(rsiData);
                        if (!rsiDashedLines) {
                            rsiDashedLines = [
                                rsiChart.addLineSeries({
                                    color: '#00FF00', 
                                    lineWidth: 1,
                                    lineStyle: 2, // Dashed line
                                }),
                                rsiChart.addLineSeries({
                                    color: '#00FF00', 
                                    lineWidth: 1,
                                    lineStyle: 2, //
                                }),
                            ];

                            const minTime = rsiData[0].time;
                            const maxTime = rsiData[rsiData.length - 1].time;

                            rsiDashedLines[0].setData([{ time: minTime, value: 70 }, { time: maxTime, value: 70 }]);
                            rsiDashedLines[1].setData([{ time: minTime, value: 30 }, { time: maxTime, value: 30 }]);
                        }
                        const closePrices = chartData.map(d => ({
                            time: d.time,
                            value: d.close
                        }));

                        const priceLows = findPivots(closePrices, false);
                        const rsiLows = findPivots(rsiData, false);

                        const priceHighs = findPivots(closePrices, true);
                        const rsiHighs = findPivots(rsiData, true);

                        

                        const bullishDivs = detectDivergence(priceLows, rsiLows, true);
                        const bearishDivs = detectDivergence(priceHighs, rsiHighs, false);

                        const allDivergences = [...bullishDivs, ...bearishDivs];

                        // console.log(bullishDivs);

                        const bullishMarkers = allDivergences.map(div => ({
                            time: div.time,
                            position: 'belowBar',
                            color: div.type === 'bullish' ? 'green' : 'red',
                            shape: 'arrowUp',
                            text: div.type === 'bullish' ? 'Bullish sign' : 'Bearish sign'
                        }));
                        rsiSeries.setMarkers(bullishMarkers);
                        console.log(bullishMarkers);
                        // const bearishMarkers = bearishDivs.map(div => ({
                        //     time: div.time,
                        //     position: 'belowBar',
                        //     color: 'red',
                        //     shape: 'arrowDown',
                        //     text: 'Bearish sign'
                        // }));

                        // const allMarkers = bullishMarkers.concat(bearishMarkers); // instead of spread
                        // rsiSeries.setMarkers(bullishMarkers);   

                        // rsiSeries.setMarkers(bearishMarkers);
                        // rsiSeries.setMarkers(bullishMarkers);
                    } else {
                        if (rsiSeries) { 
                            rsiChart.removeSeries(rsiSeries); rsiSeries = null; 
                        }
                    }
                    
                });
                // m2Data = 
                // m2Series.setData(m2Data);
                document.title = `BTC ${timeframe.toUpperCase()} - $${latestCandle.close.toFixed(2)}`;
                let timeC = "Daily (1D)";
                if(timeframe === '1d') {
                    timeC = "Daily (1D)";
                } else if (timeframe === '4h') {
                    timeC = "4-Hour (4h)";
                } else if (timeframe === '1w') {
                    timeC = "Weekly (1w)";
                }
                document.getElementById("chart-label").innerText = `Current Chart: ${timeC}`;
                         
            }
        }

        let currentTweetTime = null;

        window.onload = async function() {
            // console.log(LightweightCharts);
            if (typeof LightweightCharts === "undefined") {
                console.error("ðŸš¨ LightweightCharts is NOT loaded! Check your script tag.");
                return;
            }
            
            const chartContainer = document.getElementById('chart-container');
            if (!chartContainer) {
                console.error("Chart container not found!");
                return;
            }
            chart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth,
                height: 600,
                layout: { backgroundColor: '#ffffff', textColor: '#000' },
                grid: { vertLines: { color: '#eeeeee' }, horzLines: { color: '#eeeeee' } },
                rightPriceScale: { visible: true, borderColor: '#d1d4dc' }, // BTC on right axis
                leftPriceScale: { visible: true, borderColor: '#d1d4dc' }   // M2 on left axis
            });
            // window.addEventListener('resize', ()=>{
            //     const width = chartContainer.clientWidth;
            //     const height = chartContainer.clientHeight;
            //     chart.resize(width, height);
            // })
            // Add BTC Candlestick Series (Right Axis)
            candleSeries = chart.addCandlestickSeries({ priceScaleId: 'right' });

            

            

            lineSeries = chart.addLineSeries({
                color: 'blue', // Set the color for the line
                lineWidth: 2,  // Adjust line thickness
                zIndex : 2000
            });

            

            baseSentimentSeries = chart.addHistogramSeries({
                priceScaleId: 'left',
                lineWidth: 2
            });

            topSentimentSeries = chart.addHistogramSeries({
                priceScaleId: 'left',
                lineWidth: 2
            });

            await loadChart('1d'); // Load default chart
            // await fetchM2();
            // await fetchMaxSentData('1d');

            // Create the tooltip div
            const tooltip = document.createElement("div");
            tooltip.style.position = "absolute";
            tooltip.style.background = "white";
            tooltip.style.padding = "5px";
            tooltip.style.borderRadius = "5px";
            tooltip.style.border = "1px solid #ccc";
            tooltip.style.fontSize = "14px";
            tooltip.style.display = "none";
            tooltip.style.pointerEvents = "none"; // Prevents tooltip from interfering with mouse events
            tooltip.style.zIndex = "1000"; // Ensures tooltip appears above everything
            document.body.appendChild(tooltip);
            const smaColors = {
                20: '#1e95e3',  
                50: '#227bb5',  
                100: '#22648f', 
                200: '#1c4763',
                365: '#102b3d'
            };

            const ichiColors = {
                "Tenkansen": '#71c752',  
                "Kijunsen": '#2f4a25',  
                "Senkou Span A": '#339660', 
                "Senkou Span B": '#0ce8aa', 
                "Chikou Span": '#149ea6'
            };

            


            // Function to handle tooltip on hover
            chart.subscribeCrosshairMove(param => {
                if (!param || !param.point || !param.seriesData || !param.time) {
                    tooltip.style.display = "none";
                    tweetBox.style.display = "none";
                    return;
                }

                const { point, seriesData } = param;
                let text = "";

                // Loop through SMA lines and check if they have data at the hovered point
                Object.keys(smaLines).forEach(period => {
                    if (seriesData.has(smaLines[period])) {
                        const value = seriesData.get(smaLines[period]).value;
                        text += `<b style="color: ${smaColors[period]};">SMA ${period}:</b> ${value.toFixed(2)}<br>`;
                    }
                });

                Object.keys(fibonacciLines).forEach(level => {
                    if (seriesData.has(fibonacciLines[level])) {
                        const value = seriesData.get(fibonacciLines[level]).value;
                        text += `<b>Fibonacci ${level}:</b> ${value.toFixed(2)}<br>`;
                    }
                });

                Object.keys(ichimokuLine).forEach(period => {
                    if (seriesData.has(ichimokuLine[period])) {
                        const value = seriesData.get(ichimokuLine[period]).value;
                        const color = ichiColors[period];
                        text += `
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <span style="
                                    width: 40px;
                                    height: 4px;
                                    // background-color: ${color};
                                    border-top: 2px ${period === 'Senkou Span A' || period === 'Senkou Span B' ? 'solid' : 'dashed'} ${color};
                                "></span>
                                <b style="color: ${color};">${period}:</b> ${value.toFixed(2)}
                            </div>
                        `;
                    }
                });

                const ema = document.getElementById("ema-select").value;
                if (ema && emaSeries) {  // Check if EMA is selected and exists
                    if (seriesData.has(emaSeries)) {
                        const value = seriesData.get(emaSeries).value;
                        const color = "#f58747";
                        text += `<b style="color: ${color};">EMA ${ema}:</b> ${value.toFixed(2)}<br>`;
                    }
                }

                if(mvrvSeries){
                    
                    if (seriesData.has(mvrvSeries)) {
                        const value = seriesData.get(mvrvSeries).value;
                        const color = "#d99696";
                        text += `
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <span style="
                                width: 40px;
                                height: 4px;
                                border-top: 2px solid ${color};
                            "></span>
                            <b style="color: ${color};">MVRV:</b> ${value.toFixed(2)}<br>
                        </div>
                        `;
                    }

                    // if(signals){
                    //     const hoveredUnix = param.time; // e.g. 1745539200
                    //     const hoveredDate = new Date(hoveredUnix * 1000).toISOString().slice(0, 10); // 'YYYY-MM-DD'
                    //     const signal = signals.find(item => item.date === hoveredDate);

                    //     if (signal) {
                    //         text += `<br><b style="color: #d99696;">ðŸ“ ${signal.signal}</b><br>`;
                    //     }
                    // }
                }

                if(m2Series){
                    
                    if (seriesData.has(m2Series)) {
                        const value = seriesData.get(m2Series).value;
                        const color = "#d19a02";
                        text += `
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <span style="
                                width: 40px;
                                height: 4px;
                                border-top: 2px solid ${color};
                            "></span>
                            <b style="color: ${color};">M2:</b> ${value.toFixed(2)}<br>
                        </div>
                        `;
                    }

            
                }

                if(supertrendSeries){
                    supertrendSeries.forEach(series => {
                        if (!param.seriesData.has(series)) return;
                        const value = param.seriesData.get(series);
                        if (value) {
                            text += `
                                <b style="color: ${series.options().color};">Supertrend:</b> ${value.value.toFixed(2)}<br>
                            `;
                        }
                    });
                } 

        

                // if (stepSeries) {  // Check if EMA is selected and exists
                //     if (seriesData.has(stepSeries)) {
                //         const value = seriesData.get(stepSeries).value;
                //         const color = "#b08d04";
                //         text += `<b style="color: ${color};">Positive/Negative (Sentiment) ${ema}:</b> ${value.toFixed(2)}<br>`;
                //     }
                // }

                // if (sentimentSeries) {  // Check if EMA is selected and exists
                //     if (seriesData.has(sentimentSeries)) {
                //         const value = seriesData.get(sentimentSeries).value;
                //         const color = "#f58747";
                //         text += `<b style="color: ${color};">Sentiment ${ema}:</b> ${value.toFixed(2)}<br>`;
                //     }
                // }
                if(commentaries){
                    const hoveredTime = param.time;
                    const commentary = commentaries.find(item => item.time === hoveredTime);

                    if (commentary) {
                        const color = commentary.type === "golden" ? "#a19528" : "#cc0000";
                        text += `<b style="color: ${color};">ðŸ“ ${commentary.text}</b><br>`;
                    }
                }

                

                if(bbAlerts){
                    const hoveredTime = param.time;
                    const alert = bbAlerts.find(item => item.time === hoveredTime);

                    if (alert) {
                        const color = alert.type === "golden" ? "#75e346" : "#cc0000";
                        text += `<b style="color: #ad3131;">${alert.message}</b><br>`;
                    }
                }

                if (!param.time) return;
                if (text !== "") {
                    tooltip.innerHTML = text;
                    tooltip.style.left = `${point.x + 10}px`;
                    tooltip.style.top = `${point.y - 10}px`;
                    tooltip.style.display = "block";
                } else {
                    tooltip.style.display = "none";
                }
            });
            let tweetBoxVisible = false;
            
            // click function to make tooltip occur
            


        };
    </script>
</body>
</html>
