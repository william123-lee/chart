<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display&family=Lato&display=swap" rel="stylesheet">
    <!--<title>BTC Chart - Lightweight Version</title>-->
    <link href="https://fonts.googleapis.com/css2?family=Exo&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js" async></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/technicalindicators@3.0.1/dist/browser/technicalindicators.min.js" async></script> -->
    <style>
        /* body{
            background-color: #121212;
            color: #ffffff;
        } */
        h2 {
            font-family: 'Exo', sans-serif;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            
        }
        .chart-tooltip {
            font-family: 'Lato', sans-serif;
            font-size: 14px;
            color: #fff;
        }

        body {
            font-family: 'Lato', sans-serif;
            
        }
        #chart-container {
            width: 100%;
            height: 650px;
            position: relative;
            /*background-color: #1e1e1e;*/
            margin-bottom: 20px;
        }
        
        button {
            margin-top: 10px;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            color:#094d91;
            font-family: 'Lato', sans-serif;
        }
        #chart-label {
            font-size: 20px;
            font-weight: bold;
            margin-top: 10px;
        }
        #indicator-controls {
            position: absolute;
            top: 10px;
            right: 20px;
            margin-bottom: 20px;
            z-index: 1000;
        }

        #indicator-controls button {
            padding: 6px 12px;
            background-color: #c2d4f2;
            color: #011A41;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Lato', sans-serif;
        }

        #indicator-controls button:hover {
            background-color: #4684e8;
        }
        #indicator-controls-wrapper {
            display: flex; 
            gap: 20px; 
            align-items: flex-start;
        }
        #smaLegend {
            position: absolute;
            right: 20px;
            top: 80px;
            width: 100px;
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2); 
            text-align: left;
        }
        input[type="checkbox"] {
            accent-color: #094d91; /* modern blue */

            cursor: pointer;
        }
        select {
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: #f9f9f9;
            color: #094d91;
            outline: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        select:hover {
            border-color: #094d91;
            background-color: #eef5fc;
        }

        .axis-label {
            position: absolute;
            font-size: 14px;
            font-weight: bold;
            color: #000;
        }

        #y-axis-left-label {
            left: 5px;
            top: 50%;
            transform: rotate(-90deg);
            transform-origin: left;
        }

        #y-axis-right-label {
            right: 5px;
            top: 50%;
            transform: rotate(90deg);
            transform-origin: right;
        }

        #x-axis-label {
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
        }
        .news-container {
            position: absolute;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 12px;
            background-color: #fff;
            box-shadow: 0 6px 16px rgba(0,0,0,0.12);
            z-index: 1000;
            display: none;
            pointer-events: auto;
            width: 360px;
            max-height: 480px;
            overflow-y: auto;
            color: #222;
            line-height: 1.6;
            font-family: 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
        }

        .news-article {
            margin-bottom: 16px;
        }

        .news-article b {
            font-size: 15px;
            color: #000;
        }

        .news-article small {
            display: block;
            margin-top: 4px;
            color: #555;
        }

        .news-article a {
            color: #1a0dab;
            text-decoration: none;
        }

        .news-article a:hover {
            text-decoration: underline;
        }

        .news-article hr {
            margin-top: 12px;
            border: none;
            border-top: 1px solid #eee;
        }
        
    </style>
</head>
<body>
    <h2 style="color: #011A41">BTC Chart</h2>
    <h3 id="chart-label" style="color: #011A41">Current Chart: Daily (1D)</h3> 
    <div id="indicator-controls-wrapper">
        <div id="indicator-controls">
            <button onclick="clearAllIndicators()"> Clear All Indicators</button>
        </div>
        <div id="smaLegend"></div>
        <label for="ema-select">EMA:</label>
        <select id="ema-select">
            <option value="">None</option>
            <option value="20">EMA-20 Days</option>
            <option value="50">EMA-50 Days</option>
            <option value="200">EMA-200 Days</option>
        </select>
        <label>
            <input type="checkbox" id="bb-select"> Bollinger Bands
        </label>
        <label>
            <input type="checkbox" id="rsi-checkbox"> RSI
        </label>
        <label>
            <input type="checkbox" id="super-checkbox"> Supertrend
        </label>
        <label>
            <input type="checkbox" id="sent-checkbox"> Sentiment Analysis
        </label>
        
        <div id="sma-options"></div>
        <div id="fibonacci-options"></div>
        <div id="ichimoku-options"></div> 
        <label for="analysis-select">Analysis Indicators:</label>
        <select id="analysis-select">
            <option value="">None</option>
            <option value="m2">M2</option>
            <option value="mvrv">MVRV</option>
        </select>      
    </div>
    
    <!-- <label id="ichimoku-options"></label>
    <label id="fibonacci-options"></label>
    <label id="sma-options"></label> -->
    <div id="chart-container">
        <div id="x-axis-label" class="axis-label">Time</div>
        
    </div>
    
    <div id="rsi-container">
        Relative Strength Index (RSI)
    </div>
    <button onclick="loadChart('1d')">Daily Chart</button>
    <button onclick="loadChart('4h')">4-Hour Chart</button>
    <button onclick="loadChart('1w')">Weekly Chart</button>
    
    <script>
        let chart, chartData = [], candleSeries,  bollingerUpperSeries = null, bollingerMiddleSeries = null, bollingerLowerSeries = null, smaLines = {},
        fibonacciLines = {}, rsiSeries, rsiChart = null, rsiDashedLines, m2Series, emaSeries, sentimentSeries, baseSentimentSeries,
        topSentimentSeries, lineSeries, stepSeries, supertrendSeries = [], supertrendDownSeries, sma50 = null, sma200 = null, sma365 = null, commentaries, bbAlerts = [], 
        markers = [], unixTime = null, tweetData = [], ichimokuLine = {}, updatedMvrvData = null, mvrvSeries, signals = [], newsBoxVisible, tweetBoxVisible, time = null, supertrendSegments = []; 
        
        const tweetBox = document.createElement("div");
            tweetBox.id = "tweetBox";
            tweetBox.style.position = "absolute";
            // tweetBox.style.top = "100px";
            // tweetBox.style.left = "10px";
            tweetBox.style.padding = "16px";
            tweetBox.style.border = "1px solid #7d7c7c";
            tweetBox.style.borderRadius = "12px";
            tweetBox.style.backgroundColor = "#ffffff";
            tweetBox.style.boxShadow = "0 4px 12px rgba(0,0,0,0.08)";
            tweetBox.style.zIndex = "1000";
            tweetBox.style.display = "none";
            tweetBox.style.pointerEvents = "auto";
            tweetBox.style.width = "320px";
            tweetBox.style.maxHeight = "400px";
            tweetBox.style.overflowY = "auto";
            tweetBox.style.color = "#333";
            tweetBox.style.lineHeight = "1.5";
            document.body.appendChild(tweetBox);

            const newBox = document.createElement("div");
            newBox.id = "tweetBox";
            newBox.className = "news-container";
            document.body.appendChild(newBox);

        //HERE is to fetch the social domaninance from santiment
        //then overlay it with the btc chart

        // ** FETCHING DATA ** //
        // HERE is to fetch the BTC data from binanceAPI
        // timeframe is either '1d' or '4hr' or '1w'
        async function fetchData(timeframe) {
            try {
                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${timeframe}&limit=1000`);
                // const response = await fetch(`https://www.alphavantage.co/query?function=DIGITAL_CURRENCY_DAILY&symbol=BTC&market=USD&apikey=9WHCIQDMR3UZ2W1J`);
                const data = await response.json();

                console.log("üìä Data Length:", data.length); //1000
                //volume can be ignore
                return data.map(d => ({
                    time: d[0] / 1000,
                    open: parseFloat(d[1]),
                    high: parseFloat(d[2]),
                    low: parseFloat(d[3]),
                    close: parseFloat(d[4]),
                    volume: parseFloat(d[5])
                }));
                
            } catch (error) {
                console.error("‚ùå Error fetching data:", error);
            }
        }

        // fetching mvrv data
        async function fetchMVRV(){
            try{
                const response = await fetch('http://localhost:3000/mvrv-data');
                const data = await response.json();
                if (data?.responseData?.getMetric?.timeseriesData) {
                    const mvrvData = data.responseData.getMetric.timeseriesData;
                    displayMVRVChart(mvrvData);
                    // console.log(mvrvData);
                } else {
                    console.error("No MVRV data available");
                }
            } catch(err){
                console.error("Failed to fetch MVRV data", err);
            }
        }

        function displayMVRVChart(mvrvData){
            updatedMvrvData = mvrvData.map(item => {
                if (item.datetime) {
                    // Create a Date object from the datetime string
                    const date = new Date(item.datetime);
                    
                    // Format the date as "YYYY-MM-DD" (You can adjust the format as needed)
                    const formattedDate = date.toISOString().split('T')[0]; // "YYYY-MM-DD" format

                    // Return the new object with the formatted date
                    return {
                        
                        time: formattedDate,
                        value: item.value // Store the formatted date
                    };
                }
            });

            mvrvSeries = chart.addLineSeries({
                color: '#d99696', 
                lineWidth: 2,
                priceScaleId: 'left',
                
            });

            mvrvSeries.setData(updatedMvrvData); // Update M2 series in LightweightCharts
        }

        function detectMVRVandSMA(){
            const smaMap = new Map();
                sma365.forEach(item => {
                    const date = new Date(item.time * 1000).toISOString().slice(0, 10); // Convert to 'YYYY-MM-DD'
                    smaMap.set(date, item.value);
                });
            // console.log(smaMap);

            // First, find min/max across the entire dataset
            const mvrvValues = updatedMvrvData.map(d => d.value);
            const smaValues = updatedMvrvData.map(d => smaMap.get(d.time.slice(0, 10))).filter(v => v !== undefined);

            const minMvrv = Math.min(...mvrvValues);
            const maxMvrv = Math.max(...mvrvValues);
            const minSma = Math.min(...smaValues);
            const maxSma = Math.max(...smaValues);
            signals = [];
            let previousSignal = null;
            updatedMvrvData.forEach(item => {
                const date = item.time.slice(0, 10);
                const mvrv = item.value;
                const sma = smaMap.get(date);

                if (sma !== undefined) {
                    const normMvrv = (mvrv - minMvrv) / (maxMvrv - minMvrv);
                    const normSma = (sma - minSma) / (maxSma - minSma);
                    let currentSignal = null;
                    const diff = normMvrv - normSma;
                    let text = null;
                    if (diff > 0) {
                        currentSignal = 'Above SMA';
                        text = 'MVRV is above SMA';
                    } else if (diff < 0) {
                        currentSignal = 'Below SMA'
                        text = 'MVRV is below SMA';
                    } else {
                        currentSignal = 'Equal to SMA';
                        text = 'MVRV is equal to SMA';
                    }

                    if(currentSignal !== previousSignal){
                        signals.push({date, signal:text, diff});
                        previousSignal = currentSignal;
                    }
                }
            });  
            console.log(signals);                                   
        }
        
        // fetching twitter post - now fetching manually
        async function fetchTwitter(){
            // fetch('http://localhost:3000/twitter-post')
            // .then(response => response.json())
            // .then(data => {
            //     console.log("Username:", data.username);
            //     console.log("Text:", data.text);
            //     console.log("Timestamp:", data.timestamp);
            //     const name = data.username;
            //     const text = data.text;
            //     const timestamp = data.timestamp;
                
            //     tweetData = {
            //         username: name,
            //         text: text,
            //         timestamp: timestamp
            //     };
            
            //     const tweetDate = new Date(timestamp);
            //     unixTime = Math.floor(tweetDate.getTime()/1000);
            //     console.log(timestamp);
            //     tweetDate.setUTCHours(0, 0, 0, 0);
            //     console.log(tweetDate);
            //     const normalizedUnixTime = Math.floor(tweetDate.getTime() / 1000);
            //     console.log(normalizedUnixTime);
            //     const twitMarker = [{
            //         time: normalizedUnixTime,
            //         position: 'belowBar', 
            //         color: '#1DA1F2', // Twitter blue
            //         shape: 'square', 
            //         text: 'üê¶ Twitter Analysis', 
            //     }];
            //     setMarkers(twitMarker);
            // })
            // .catch(error => {
            //     console.error("Error fetching tweet info:", error);
            // });

            const name = "CryptoHayes";
            const text = "I bet $BTC hits $110k before it retests $76.5k.\n Y? The Fed is going from QT to QE for treasuries. And tariffs don‚Äôt matter cause ‚Äútransitory inflation‚Äù. JAYPOW told me so.\n I‚Äôll expound on that in my next essay, that‚Äôs the TLDR for your TikTok peanut brain."
            const timestamp = "2025-03-24T02:42:09.000Z";
            const profile = 'https://pbs.twimg.com/profile_images/1860844599088189440/dH1AnJGk_normal.jpg';
            tweetData.push ({
                username: name,
                text: text,
                timestamp: timestamp,
                profile: profile,
                tweetID: '1904000755381760058'
            });

            tweetData.push({
                username: "test",
                text: "testText",
                timestamp: "2025-04-14T02:42:09.000Z",
                tweetID: '1904000755381760050'
            })
           

            const date = new Date(timestamp).toISOString().split("T")[0];
            let twitMarker = [{
                time:date,
                position: 'belowBar', 
                color: '#1a4670', // Twitter blue
                shape: 'circle', 
                size: 2,
                text: 'Analysis', 
            },
            {
                time: { year: 2025, month: 4, day: 14},
                position: 'belowBar', 
                color: '#1a4670', // Twitter blue
                shape: 'circle', 
                size: 2,
                text: 'Analysis', 
            }];
            setMarkers(twitMarker);

            
            tweetBoxVisible = false;
            chart.subscribeClick(function (param) {
                if (!param || !param.time) return;

                // Check if the click was on the marker (mouse's movement)
                const clickedTime = param.time;
                // console.log(isSameDate(clickedTime, unixTime));
                    const x = param.point.x;
                    const y = param.point.y;
                    // console.log(x,y);
                    if (tweetBoxVisible) {
                        // If tweetBox is visible, hide it
                        tweetBox.style.display = "none";
                        tweetBoxVisible = false;
                    }else {
                        // If tweetBox is not visible, show it and position it
                        if(newsBoxVisible){
                            newBox.style.display = "none";
                            newsBoxVisible = false;
                        }
                        tweetBox.innerHTML = "";
                        tweetBox.style.left = `${x + 100}px`;
                        tweetBox.style.top = `${y - tweetBox.offsetHeight - 15}px`;
                        tweetData.forEach(tweet => {
                            const tweetTime = Math.floor(new Date(tweet.timestamp).getTime()/1000);
                            // check if the mouse's time match with the tweet's time from each tweet
                            // if yes, put text and show tweetBox, if no just skip
                            if(isSameDate(clickedTime, tweetTime)){ 
                                // console.log(tweet.username);
                                tweetBox.innerHTML += `
                                <div class="tweet">
                                    <img src="${tweet.profile}" style="width:30px; height:30px; border-radius:50%;" onerror="this.onerror=null; this.src='default-profile.png';"/>
                                    <b>@${tweet.username}</b><br><br>
                                    ${tweet.text}<br><br>
                                    <small>${tweet.timestamp}</small>
                                    <hr>
                                </div>
                            `;
                                tweetBox.style.display = "block";
                                tweetBoxVisible = true;
                            }
                        });
                        
                       
                        // hideTimeout = setTimeout(() => {
                        //     tweetBox.style.display = "none";
                        //     tweetBoxVisible = false;
                        // }, 10000); // 5000 milliseconds = 5 seconds
                    }
                // }
            });
        }
 
        //HERE is to fetch the old news and set the markers including trump/btc price/other events
        //need to add importantDate as param if its called by fetchEvent(); no need if called by loadChart()
        async function fetchNew(chartData){
            let allNewsData = [];
            console.log(time);
            //http://localhost:3000/news-data-old
            await fetch('https://chart-backend-0rxq.onrender.com/news-data-old')
            .then(res => res.json())
            .then(data => {
                // console.log("All Combined News Data:", data);
                let allNewsData = data;

                let importantEvents = [];
                const latestCandle = chartData[chartData.length - 1];
                // const markerTime = new Date(latestCandle.time * 1000).toISOString().split('T')[0];
                const markerTime = latestCandle.time; 
                
                if(chartData){
                    //HERE is to set the initial markers - for now no use
                    let initialMarkers = [{
                                time: '2024-11-05', // Ensure this matches data format
                                position: 'aboveBar', 
                                color: '#f74d4d', 
                                shape: 'circle', 
                                text: 'Trump Election', 
                                size:2
                            },
                            {
                                time: markerTime, 
                                position: 'belowBar', 
                                color: '#cc5118', // Marker color
                                shape: 'arrowUp', 
                                text: 'BTC Closing Price($)', 
                                size:2
                            }
                        ];
                        // console.log(markerTime);
                    if (latestCandle) {
                        // setMarkers(initialMarkers);
                        // console.log(markerTime);
                    } else {
                        console.error('latestCandle is undefined or null');
                    }
                
                    

                    if (allNewsData) {
                        try {
                            // Check if `feed` exists and is an array
                            if (allNewsData && Array.isArray(allNewsData)) {
                                // Example filter for important events
                                const keywords = [
                                    "inflation", "interest rate", "GDP", "recession", "subsidies", 
                                    "stimulus", "default", "bankruptcy", "merger", "acquisition", "bitcoin falls"
                                ];
                                allNewsData = allNewsData.filter(item => item && item.title);
                                // console.log(allNewsData);

                                // Filter news articles based on the keywords defined
                                importantEvents = allNewsData.filter(article => {
                                    return keywords.some(keyword => 
                                        article.title.toLowerCase().includes(keyword)
                                    );
                                });
                                console.log(importantEvents);
                                const chartMarkers = [];          
                                //group articles based on published date                 
                                const groupedArticles1 = importantEvents.reduce((acc, article) => {
                                    // Extract the date (ignore time)
                                    const date = new Date(article.publishedAt).toISOString().split("T")[0];
                                                        
                                    // If the date does not exist in the accumulator, create an empty array for it
                                    if (!acc[date]) {
                                        acc[date] = [];
                                    }

                                                    // Add the article to the respective date group
                                    acc[date].push(article);
                                                        
                                    return acc;
                                }, {});
                                console.log(groupedArticles1);

                                // create markers for each date
                                Object.keys(groupedArticles1).forEach(date => {
                                    const articles = groupedArticles1[date];
                                    const d = new Date(date);
                                    let markertime;
                                    if (time === '1d') {
                                        // Use exact date
                                        markertime = date;
                                    } else if (time === '1w') {
                                        // Align to start of the week (Sunday or Monday depending on your chart)
                                        const day = d.getDay(); // 0 = Sunday
                                        const diff = d.getDate() - day;
                                        d.setDate(diff);
                                        d.setHours(0, 0, 0, 0);
                                        markertime = Math.floor(d.getTime() / 1000);
                                    } else {
                                        markertime = date;
                                    }
                                    // Create a marker for each day (you can adjust this based on your charting library)
                                    chartMarkers.push({
                                        time: markertime,
                                        position: "aboveBar",
                                        color: '#f74d4d',
                                        shape: "circle",
                                        text: "News Update",
                                        size:2 
                                    });
                                });

                                setMarkers(chartMarkers); 
                                
                                newsBoxVisible = false;
                                // chart.subscribeClick(function (param) {
                                //     if (!param || !param.time) return;
                                    
                                //     const clickedTime = param.time;
                                //     const clickedDate = new Date(clickedTime * 1000);  // Keep it as a Date object
                                //     console.log("Clicked Date Object:", clickedDate);

                                //     const formattedDate = `${clickedDate.getFullYear()}-${String(clickedDate.getMonth() + 1).padStart(2, '0')}-${String(clickedDate.getDate()).padStart(2, '0')}`; // Format it only when needed
                                //     console.log("Clicked Date String:", formattedDate);
                                    
                                //     // Check if there's any article for this clicked date
                                //     articles = groupedArticles1[formattedDate];  // Ensure this matches the format in groupedArticles
                                //     console.log(articles);
                                //     // Check if articles exist for the clicked date
                                //     if (articles && articles.length > 0) {
                                //         const x = param.point.x;
                                //         const y = param.point.y;
                                        
                                //         // Display the articles if available
                                //         if (newsBoxVisible) {
                                //             newBox.style.display = "none";
                                //             newsBoxVisible = false;
                                //         }else{
                                            
                                //             if(tweetBoxVisible){
                                //                 tweetBox.style.display = "none";
                                //                 tweetBoxVisible = false;
                                //             }

                                //             newBox.innerHTML = ""; // Clear previous content
                                //             newBox.style.left = `${x + 100}px`;
                                //             newBox.style.top = `${y - newBox.offsetHeight - 15}px`;
                                            
                                //             articles.forEach(article => {
                                //                 newBox.innerHTML += `
                                //                     <div class="news-article">
                                //                         <b>${article.title}</b><br>
                                //                         <small>${article.publishedAt}</small>
                                //                         <small><a href = "${article.url}">${article.url}</a></small><br><br>
                                //                         <hr>
                                //                     </div>
                                //                 `;
                                //             });

                                //             newBox.style.display = "block";
                                //             newsBoxVisible = true;
                                //         }
                                //     } else {
                                //         console.log("No articles found for date:", formattedDate);
                                //     }
                                // });

                                
                                //iE = w/o taking the fund rate
                                //eD = take event start with date based on fund rate
                                //HERE is to set the markers of the events filtered
                                
                                chart.subscribeClick(function (param) {
                                    if (!param || !param.time) return;

                                    const clickedTime = param.time;
                                    const clickedDate = new Date(clickedTime * 1000);

                                    console.log("Clicked Date Object:", clickedDate);
                                    const articlesToShow = [];

                                    // Loop through all groupedArticles1 to check within time ranges
                                    for (const dateKey in groupedArticles1) {
                                        const articleDate = new Date(dateKey);  // Each key is in YYYY-MM-DD
                                        const articleTimestamp = articleDate.getTime();
                                        const clickedTimestamp = clickedDate.getTime();

                                        let match = false;

                                        if (time === '1d') {
                                            // Daily ‚Äî exact date match
                                            match = clickedDate.toDateString() === articleDate.toDateString();
                                        } else if (time === '1w') {
                                            // Weekly ‚Äî compare if in the same week
                                            const clickedWeekStart = getStartOfWeek(clickedDate);
                                            const articleWeekStart = getStartOfWeek(articleDate);
                                            match = clickedWeekStart.getTime() === articleWeekStart.getTime();
                                        } else {
                                            match = clickedDate.toDateString() === articleDate.toDateString();
                                        }
                                            // } else if (time === '1M') {
                                        //     // Monthly ‚Äî compare year and month
                                        //     match = clickedDate.getFullYear() === articleDate.getFullYear() &&
                                        //             clickedDate.getMonth() === articleDate.getMonth();
                                        // }

                                        if (match) {
                                            articlesToShow.push(...groupedArticles1[dateKey]);
                                        }
                                        console.log(articlesToShow);
                                    }

                                    if (articlesToShow.length > 0) {
                                        const x = param.point.x;
                                        const y = param.point.y;

                                        if (newsBoxVisible) {
                                            newBox.style.display = "none";
                                            newsBoxVisible = false;
                                        } else {
                                            if (tweetBoxVisible) {
                                                tweetBox.style.display = "none";
                                                tweetBoxVisible = false;
                                            }

                                            newBox.innerHTML = ""; // Clear previous content
                                            newBox.style.left = `${x + 100}px`;
                                            newBox.style.top = `${y - newBox.offsetHeight - 15}px`;

                                            articlesToShow.forEach(article => {
                                                newBox.innerHTML += `
                                                    <div class="news-article">
                                                        <b>${article.title}</b><br>
                                                        <small>${article.publishedAt}</small>
                                                        <small><a href="${article.url}">${article.url}</a></small><br><br>
                                                        <hr>
                                                    </div>
                                                `;
                                            });

                                            newBox.style.display = "block";
                                            newsBoxVisible = true;
                                        }
                                    } else {
                                        console.log("No articles found for the selected timeframe.");
                                    }
                                
                                });
                                
                                
                                const newMarkers = importantEvents.map(event => {
                                    let rawDate = event.publishedAt || ""; // Get time_published safely
                                    let formattedDate = "";
                                    // console.log(rawDate);
                                    if (rawDate) {
                                        try {
                                            // Convert ISO 8601 timestamp to YYYY-MM-DD format
                                            let dateObj = new Date(rawDate);
                                            formattedDate = dateObj.toISOString().split("T")[0]; // Extract YYYY-MM-DD
                                            
                                        } catch (error) {
                                            console.warn(`Invalid date format detected: ${rawDate}, using fallback.`);
                                            formattedDate = "2024-01-01"; // Fallback date
                                        }
                                    } else {
                                        console.warn(`Missing date for event: ${event.title}`);
                                        formattedDate = "2024-01-01"; // Fallback date
                                    }

                                    return {
                                        time: formattedDate,
                                        position: "aboveBar",
                                        color: '#f74d4d',
                                        shape: "circle",
                                        text: event.title,
                                        size:2
                                    };
                                
                                });
                                // setMarkers(newMarkers);                   
                            } else {
                                console.error("‚ö†Ô∏è ERROR: `newsData.feed` is missing or not an array. Full object:", allNewsData);
                            }
                            } catch (error) {
                                console.error("‚ö†Ô∏è ERROR: Failed to parse news data:", error);
                            }
                            } else {
                                console.log("‚ö†Ô∏è No news data found in localStorage.");
                            }
                    
                } 
            })
            .catch(err => console.error("Failed to fetch news:", err));
        }
        function getStartOfWeek(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day;
            return new Date(d.setDate(diff));
        }

        //HERE is to fetch the M2 data using backend with federal reserve API
        async function fetchM2() {
            const API_URL = "https://chart-backend-0rxq.onrender.com/m2-data"; // Fetch from local server
            //http://localhost:3000/m2-data
            
            try {
                let response = await fetch(API_URL);
                let data = await response.json();
                let observations = data.observations;
                let m2Data = observations.map(d => ({
                    time: d.date,  // Ensure format is YYYY-MM-DD
                    value: parseFloat(d.value)
                }));
                //Add M2 Line Series (Left Axis)
                m2Series = chart.addLineSeries({
                    color: '#d19a02', 
                    lineWidth: 2,
                    priceScaleId: 'left',
                    
                });

               m2Series.setData(m2Data); // Update M2 series in LightweightCharts
               if (m2Data.length > 0) {
                    let latestM2 = m2Data[m2Data.length - 1]; // Get the latest data point
                    console.log("im here", m2Series);
                    m2Series.setMarkers([
                        {
                            time: latestM2.time,  // Ensure this matches the format in setData()
                            position: 'aboveBar', // Position marker above the data point
                            color: '#d19a02',     // Marker color
                            shape: 'arrowDown',   // Shape type
                            text: `M2: $${latestM2.value} Billion`, // Display the value
                            size: 2,
                            textFontSize: 40
                        }
                    ]);
                }
            } catch (error) {
                console.error("Error fetching M2 data:", error);

            }
        }


        //HERE is to fetch the sentiment data from santiment
        // calculate the sentiment ratio - now no use
        function fetchMaxSentData(timeframe){
            const sentNeg = JSON.parse(localStorage.getItem('sentNeg'));
            const sentPos = JSON.parse(localStorage.getItem('sentPos'));
            // console.log(sentNeg);
            // console.log(sentPos);
            const combinedSentimentData = [];
            sentPos.sentiment_positive.forEach((posItem, index) => {
                const negItem = sentNeg.sentiment_negative[index];
                console.log(posItem.value, negItem.value)
                // Combine the positive and negative sentiment data into one object
                if (posItem.datetime === negItem?.datetime){
                    const sentimentRatio = negItem.value !== 0 ? posItem.value / negItem.value : null;
                    if(sentimentRatio != null){
                        combinedSentimentData.push({
                        datetime: posItem.datetime, // Date from the positive sentiment data
                        value: sentimentRatio, // Positive sentiment value
                       });
                    }
                    // if(sentimentRatio<1){
                    //     console.log(sentimentRatio);
                    // }
                }
                    
            });

            const stepData1 = combinedSentimentData.map(item => ({
                time: new Date(item.datetime).getTime() / 1000, // Convert datetime to Unix timestamp (seconds)
                value: item.value
            }));

            
            const stepData = [];
            for (let i = 0; i < combinedSentimentData.length; i++) {
                stepData.push({
                    time: new Date(combinedSentimentData[i].datetime).getTime() / 1000,
                    value: combinedSentimentData[i].value
                });

                if (i < combinedSentimentData.length - 1) {
                    stepData.push({
                        time: new Date(combinedSentimentData[i + 1].datetime).getTime() / 1000,
                        value: combinedSentimentData[i].value
                    });
                }
            }
            
            stepSeries = chart.addLineSeries({
                priceScaleId: 'left',
                // crosshairMarkerVisible: true,
                color: "#b08d04",
                lineWidth: 1,
                zIndex: "2000"
            });

            
           
            console.log("Line 175");
            stepSeries.setData(stepData1);
            
        }

        // fetching then plotting the sentiment data
        // now no use
        async function fetchSentimentData() {
            try {
                const combinedSentimentData = [];
                // const response = await fetch('http://localhost:3000/sentiment-data');
                // const data = await response.json();
                // localStorage.setItem('sentNeg', JSON.stringify(data));
                //sentNeg = interval-1d
                //sentNegMax = aggregation-MAX
                const sentNeg = JSON.parse(localStorage.getItem('sentNeg'));
                const sentPos = JSON.parse(localStorage.getItem('sentPos'));
                if (sentPos && Array.isArray(sentPos.sentiment_positive)) {
                    // Loop through the array to extract the 'value' for each item
                    sentPos.sentiment_positive.forEach((posItem, index) => {
                        const negItem = sentNeg.sentiment_negative[index];
                        
                        // Combine the positive and negative sentiment data into one object
                        if (posItem.datetime === negItem?.datetime){
                            combinedSentimentData.push({
                                datetime: posItem.datetime, // Date from the positive sentiment data
                                sentimentPositive: posItem.value, // Positive sentiment value
                                sentimentNegative: negItem ? negItem.value : 0 // Negative sentiment value, with 0 as fallback
                            });
                        }
                        // console.log(posItem.datetime, posItem.value, negItem.value);
                    });
                    // console.log(combinedSentimentData);
                    drawSentiment(combinedSentimentData);
                } else {
                    console.log("No valid sentiment data found.");
                }
                // // Add sentiment data to the chart
                // sentimentSeries.setData(sentimentData);
                // if(sentimentSeries){
                //     // console.log("Im here");
                //     let latest = sentimentData[sentimentData.length - 1];
                //     sentimentSeries.setMarkers([
                //         {
                //             time: latest.time,  // Ensure this matches the format in setData()
                //             position: 'aboveBar', // Position marker above the data point
                //             color: '#1E90FF',     // Marker color
                //             shape: 'arrowDown',   // Shape type
                //             text: `Social Volume: ${latest.value}`, // Display the value
                //             size: 2,
                //             textFontSize: 40
                //         }
                //     ]);
                // }

            } catch (error) {
                console.error('Error fetching sentiment data:', error);
            }
        }

        // draw sentiment histogram that shows the total post 
        function toggleSentimentLine() {
            const sentimentCheckbox = document.getElementById('sent-checkbox');
            if (sentimentCheckbox.checked) {
                // If the checkbox is checked, draw the sentiment line
                fetchSentimentData();
            } else {
                // If the checkbox is unchecked, remove the sentiment line
                if (sentimentSeries) {
                    // Remove the sentiment line series if it exists
                    chart.removeSeries(sentimentSeries);
                    sentimentSeries = null;
                }
            }
        }
       
        function drawSentiment(sentimentData) {
            const sentimentBars = [];

            sentimentData.forEach(item => {
                const time = item.datetime;

                const positive = item.sentimentPositive;
                const negative = item.sentimentNegative;

                const totalVolume = positive + negative;

                const isPositiveDominate = positive > negative;
                const color = isPositiveDominate 
                    ? 'rgba(75, 192, 192, 0.8)'    // Green for bullish
                    : 'rgba(255, 99, 132, 0.8)';   // Red for bearish

                if(positive==negative){
                    console.log("Yes");
                }
                sentimentBars.push({
                    time,
                    value: totalVolume,
                    color
                });
            });
            sentimentSeries = chart.addHistogramSeries({
                lineWidth: 2,
                priceScaleId: 'left'  // You can use the left axis, or create a separate axis for sentiment
            });
            // sentimentSeries.applyOptions({
            //     priceScaleId: ''
            // });
            // console.log(sentimentSeries);
            sentimentSeries.applyOptions({
                priceScaleId: '' // This effectively removes the Y-axis for this series
            });
            sentimentSeries.setData(sentimentBars);
            // console.log(sentimentSeries);
        }

        //HERE is to fetch the federal fund rate to determine whether at that day spikes
        //now didn't use it
        async function fetchEvent(chartData) {
            const API_URL = "https://chart-backend-0rxq.onrender.com/event-data"; // Fetch from local server

            try {
                let response = await fetch(API_URL);
                let data = await response.json();
                // console.log(data);
            
                let observations = data.observations;
                let importantDate = [];

                //HERE is to calculate the changes of the rate
                for (let i = 1; i < observations.length; i++) {
                    let prevRate = parseFloat(observations[i - 1].value);
                    let currRate = parseFloat(observations[i].value);
                    let date = observations[i].date;

                    let change = (currRate - prevRate).toFixed(2);

                    //HERE is to calculate the changes of the rate
                    //if >= +-0.5, its consider huge and can push the date 
                    if (Math.abs(change) >= 0.5) { // Detect large rate changes
                        importantDate.push(date);
                        // console.log(date, change);
                    }
                    
                }
                //HERE is to fetch the news on the date pushed
                fetchNew(chartData, importantDate);
               
            } catch (error) {
                    console.error("Error fetching event data:", error);
                }
            
        }

        // fetching news - no use for now
        async function fetchMacroData() {
            const API_URL = "http://localhost:3000/truf-news"; // Fetch from local server

            try {
                let response = await fetch(API_URL);
                let data = await response.json();
                console.log(data);
            } catch (error) {
                console.error("Error fetching Macro data:", error);
            }
        }
        

        // ** TECHNICAL INDICATORS ** //
        
        function calculateIchimoku(data) {
            let result = {
                tenkanSen: [],
                kijunSen: [],
                senkouSpanA: [],
                senkouSpanB: [],
                chikouSpan: []
            };

            const interval = data[1].time - data[0].time; // e.g., 86400 for daily

            for (let i = 0; i < data.length; i++) {
                // Tenkan-sen: 9-period
                if (i >= 8) {
                    const slice = data.slice(i - 8, i + 1);
                    const high = Math.max(...slice.map(d => d.high));
                    const low = Math.min(...slice.map(d => d.low));
                    const tenkan = {
                        time: data[i].time,
                        value: (high + low) / 2
                    };
                    result.tenkanSen[i] = tenkan;
                    // console.log(result.tenkanSen[i])
                } 
                

                // Kijun-sen: 26-period
                if (i >= 26) {
                    const slice = data.slice(i - 26, i + 1);
                    const high = Math.max(...slice.map(d => d.high));
                    const low = Math.min(...slice.map(d => d.low));
                    const kijun = {
                        time: data[i].time,
                        value: (high + low) / 2
                    };
                    result.kijunSen[i] = kijun;
                    // console.log(result.kijunSen[i]);
                } 

                // Senkou Span A: (Tenkan + Kijun) / 2, plotted 26 periods ahead
                if (i >= 26) {
                    const tenkan = result.tenkanSen[i]?.value ?? null;
                    const kijun = result.kijunSen[i]?.value ?? null;
                    // console.log(tenkan, kijun);
                    
                    if (tenkan !== null && kijun !== null) {
                        const value = (tenkan+kijun) / 2;
                        const futureTime = data[i].time + (26 * interval);
                        const spanA = {
                            time: futureTime,
                            value: value
                        }
                        result.senkouSpanA[i+26] = spanA;
                    }

                }

                // Senkou Span B: 52-period high/low average, plotted 26 periods ahead
                if (i >= 51) {
                    const futureTime = data[i].time + (26 * interval);
                    const slice = data.slice(i - 51, i + 1);
                    const high = Math.max(...slice.map(d => d.high));
                    const low = Math.min(...slice.map(d => d.low));
                    const value = (high + low) / 2;
                    const spanB = {
                        time: futureTime,
                        value: value
                    }
                    result.senkouSpanB[i + 26] = spanB;
                }

                // // Chikou Span: close price, plotted 26 periods back
                if (i >= 26) {
                    const chikou = {
                        value: data[i].close,
                        time: data[i-26].time
                    }
                    result.chikouSpan[i - 26] = chikou;

                }
            }
            console.log(result);
            

            // tenkansenSeries = chart.addLineSeries({ color: '#71c752', lineWidth: 2 });
            // kijunsenSeries = chart.addLineSeries({ color: '#2f4a25', lineWidth: 2 });
            // spanASeries = chart.addLineSeries({ color: '#339660', lineWidth: 2 });
            // spanBSeries = chart.addLineSeries({ color: '#0ce8aa', lineWidth: 2 });
            // chikouSeries = chart.addLineSeries({ color: '#149ea6', lineWidth: 2 });
            // console.log(tenkansenSeries);
            result.tenkanSen = result.tenkanSen.filter(p => p !== undefined);
            result.kijunSen = result.kijunSen.filter(p => p !== undefined);
            result.senkouSpanA = result.senkouSpanA.filter(p => p !== undefined);
            result.senkouSpanB = result.senkouSpanB.filter(p => p !== undefined);
            result.chikouSpan = result.chikouSpan.filter(p => p !== undefined);

            return result;
        }

        function createIchimokuCheckboxes(chartData) {
            const ichiContainer = document.getElementById("ichimoku-options");
            ichiContainer.innerHTML = ""; // Clear existing checkboxes

            const ichimokuLine = ["Tenkansen", "Kijunsen", "Senkou Span A", "Senkou Span B", "Chikou Span"]; 

            const details = document.createElement("details");
            const summary = document.createElement("summary");
            summary.innerText = "Ichimoku Analysis";
            details.appendChild(summary);

            const checkboxContainer = document.createElement("div");
            checkboxContainer.style.display = "flex";
            checkboxContainer.style.flexDirection = "column";
            checkboxContainer.style.padding = "8px";

            ichimokuLine.forEach(period => {
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.id = `ichimoku-${period}`;
                checkbox.value = period;
                //HERE is to call the function to draw lines
                checkbox.addEventListener("change", function () {
                    toggleIchimoku(period, this.checked, chartData);
                });

                const label = document.createElement("label");
                label.htmlFor = `ichimoku-${period}`;
                label.innerText = `${period}`;

                const div = document.createElement("div");
                div.style.display = "flex";
                div.style.alignItems = "center";
                div.style.gap = "5px";

                div.appendChild(checkbox);
                div.appendChild(label);
                checkboxContainer.appendChild(div);
            });

            details.appendChild(checkboxContainer);
            ichiContainer.appendChild(details);
        }

        function toggleIchimoku(period, checked, chartData) {
            const ichiColors = {
                "Tenkansen": '#71c752',  
                "Kijunsen": '#2f4a25',  
                "Senkou Span A": '#339660', 
                "Senkou Span B": '#0ce8aa', 
                "Chikou Span": '#149ea6'
            };
            // const color = ichiColors[period];
            if (checked) {
                if (!ichimokuLine[period]) {
                    // console.log(period);
                    if(period == "Senkou Span A" || period == "Senkou Span B"){
                        ichimokuLine[period] = chart.addLineSeries({
                            color: ichiColors[period], 
                            lineWidth: 2, 
                            lineStyle: 0 // Solid Line
                        });
                    }else{
                        ichimokuLine[period] = chart.addLineSeries({
                            color: ichiColors[period], 
                            lineWidth: 2, 
                            lineStyle: 2 // Dashed Line
                        });
                    }

                    
                }
                //HERE is to call the function for calculation
                const ichimoku = calculateIchimoku(chartData);
                
                const keyMap = {
                    "Tenkansen": "tenkanSen",
                    "Kijunsen": "kijunSen",
                    "Senkou Span A": "senkouSpanA",
                    "Senkou Span B": "senkouSpanB",
                    "Chikou Span": "chikouSpan"
                };
                const seriesData = ichimoku[keyMap[period]];
                console.log(seriesData);
                ichimokuLine[period].setData(seriesData);
            } else {
                if (ichimokuLine[period]) {
                    chart.removeSeries(ichimokuLine[period]);
                    delete ichimokuLine[period];
                    // commentaries = null;
                }
                
            }
        }
        // supertrend - accuracy might need double confirm
        // no use now

        async function fetchSupertrend() {
            // Clear old Supertrend series

            const API_URL = "http://localhost:5000/supertrend"; // Fetch from local server
            
            try {
                let response = await fetch(API_URL);
                let data = await response.json();
                console.log(supertrendSeries);
                const upTrend = [];
                const downTrend = [];
                
                // const supertrendSegments = [];
                let currentSegment = [];
                let isUptrend = null;

                for (let i = 0; i < data.length; i++) {
                    const time = data[i].timestamp / 1000;
                    const value = data[i]["SUPERT_10_3.0"];
                    const direction = data[i]["SUPERTd_10_3.0"];

                    if (direction === 1 || direction === -1) {
                        const up = direction === 1;
                        if (isUptrend !== up) {
                            if (currentSegment.length) {
                                supertrendSegments.push({
                                    data: currentSegment,
                                    color: isUptrend ? 'green' : 'red'
                                });
                                currentSegment = [];
                            }
                            isUptrend = up;
                        }
                        currentSegment.push({ time, value });
                    }
                }

                // Push last segment
                if (currentSegment.length) {
                    supertrendSegments.push({
                        data: currentSegment,
                        color: isUptrend ? 'green' : 'red'
                    });
                }
                // console.log(supertrendSegments);
                // Render each segment as its own line series
                supertrendSegments.forEach(segment => {
                    const series = chart.addLineSeries({
                        color: segment.color,
                        lineWidth: 2,
                        lastValueVisible: false,
                        priceLineVisible: false,
                        lineStyle: 2

                    });
                    series.setData(segment.data);
                    supertrendSeries.push(series);
                });


            } catch (error) {
                console.log("Error fetching data", error);
            }
        }

        async function fetchSupertrend4h(){

            try {
                let response = await fetch("http://localhost:5000/supertrend4h");
                let data = await response.json();
                const upTrend = [];
                const downTrend = [];
                console.log(supertrendSeries);
                let currentSegment = [];
                let isUptrend = null;

                for (let i = 0; i < data.length; i++) {
                    const time = data[i].timestamp / 1000;
                    const value = data[i]["SUPERT_10_3.0"];
                    const direction = data[i]["SUPERTd_10_3.0"];

                    if (direction === 1 || direction === -1) {
                        const up = direction === 1;
                        if (isUptrend !== up) {
                            if (currentSegment.length) {
                                supertrendSegments.push({
                                    data: currentSegment,
                                    color: isUptrend ? 'green' : 'red'
                                });
                                currentSegment = [];
                            }
                            isUptrend = up;
                        }
                        currentSegment.push({ time, value });
                    }
                }

                // Push last segment
                if (currentSegment.length) {
                    supertrendSegments.push({
                        data: currentSegment,
                        color: isUptrend ? 'green' : 'red'
                    });
                }
                // console.log(supertrendSegments);
                // Render each segment as its own line series
                supertrendSegments.forEach(segment => {
                    const series = chart.addLineSeries({
                        color: segment.color,
                        lineWidth: 2,
                        lastValueVisible: false,
                        priceLineVisible: false,
                        lineStyle: 2

                    });
                    series.setData(segment.data);
                    supertrendSeries.push(series);
                });


            } catch (error) {
                console.log("Error fetching data", error);
            }
        }

        let count = 0;
        async function fetchSupertrend1w(){
            count+=1;
            console.log(count);
            try {
                let response = await fetch("http://localhost:5000/supertrend1w");
                let data = await response.json();
                console.log(supertrendSeries);
                const upTrend = [];
                const downTrend = [];
               
                let currentSegment = [];
                let isUptrend = null;

                for (let i = 0; i < data.length; i++) {
                    const time = data[i].timestamp / 1000;
                    const value = data[i]["SUPERT_10_3.0"];
                    const direction = data[i]["SUPERTd_10_3.0"];

                    if (direction === 1 || direction === -1) {
                        const up = direction === 1;
                        if (isUptrend !== up) {
                            if (currentSegment.length) {
                                supertrendSegments.push({
                                    data: currentSegment,
                                    color: isUptrend ? 'green' : 'red'
                                });
                                currentSegment = [];
                            }
                            isUptrend = up;
                        }
                        currentSegment.push({ time, value });
                    }
                }

                // Push last segment
                if (currentSegment.length) {
                    supertrendSegments.push({
                        data: currentSegment,
                        color: isUptrend ? 'green' : 'red'
                    });
                }
                // console.log(supertrendSegments);
                // Render each segment as its own line series
                supertrendSegments.forEach(segment => {
                    const series = chart.addLineSeries({
                        color: segment.color,
                        lineWidth: 2,
                        lastValueVisible: false,
                        priceLineVisible: false,
                        lineStyle: 2

                    });
                    series.setData(segment.data);
                    supertrendSeries.push(series);
                });


            } catch (error) {
                console.log("Error fetching data", error);
            }
        }

        function handleSupertrendToggle() {
            if ((document.getElementById('super-checkbox')).checked) {
                if (time === '1d') fetchSupertrend();
                else if (time === '4h') fetchSupertrend4h();
                else if (time === '1w') fetchSupertrend1w();
            } else {
                supertrendSeries.forEach(series => chart.removeSeries(series));
                supertrendSeries = [];
                supertrendSegments = [];
            }
        }


        function addSupertrend(data){
            
            const period = 3; // average true range
            const multiplier = 3; // adjust sensitivity
            let atrValue = 0;

            // Step 1: Calculate True Range (TR) and Average True Range (ATR)
            const tr = [];
            for (let i = 1; i < data.length; i++) {
                const currentHigh = data[i].high;
                const currentLow = data[i].low;
                const prevClose = data[i - 1].close;

                const highLow = currentHigh - currentLow;
                const highClose = Math.abs(currentHigh - prevClose);
                const lowClose = Math.abs(currentLow - prevClose);
                const trueRange = Math.max(highLow, highClose, lowClose);
                tr.push(trueRange);
            }

            // Step 2: Calculate ATR
            const atr = [];
            let sum = tr.slice(0, period).reduce((acc, val) => acc + val, 0);
            atr.push(sum / period);

            for (let i = period; i < tr.length; i++) {
                const prevATR = atr[atr.length - 1];
                const currentATR = (prevATR * (period - 1) + tr[i]) / period;
                atr.push(currentATR);
            }

            // Step 3: Calculate Upper and Lower Bands
            let baseUp = [];
            let baseDown = [];
            for (let i = 0; i < period - 1; i++) {
                baseUp.push(NaN);
                baseDown.push(NaN);
            }

            for (let i = period - 1; i < data.length; i++) {
                const atrIndex = i - (period - 1); // shift ATR into alignment
                const hl2 = (data[i].high + data[i].low) / 2;
                const expectedATR = atr[atrIndex];

                if (expectedATR !== undefined && !isNaN(expectedATR)) {
                    const upper = hl2 + (multiplier * expectedATR);
                    const lower = hl2 - (multiplier * expectedATR);
                    console.log(`i=${i}, atrIndex=${atrIndex}, HL2=${hl2.toFixed(2)}, ATR=${expectedATR.toFixed(2)}, baseUp=${upper.toFixed(2)}, baseDown=${lower.toFixed(2)}`);
                }
                if (atr[atrIndex] !== undefined && !isNaN(atr[atrIndex])) {
                    baseUp.push(hl2 + (multiplier * atr[atrIndex]));
                    baseDown.push(hl2 - (multiplier * atr[atrIndex]));
                } else {
                    baseUp.push(NaN);
                    baseDown.push(NaN);
                }
            }
            console.log("First ATR should align with data at i = period - 1");
            console.log("data index:", period - 1, "=> data[period-1].hl2 =", (data[period - 1].high + data[period - 1].low) / 2);
            console.log("atr[0] =", atr[0]);

            // Step 4: Calculate Final Upper and Lower Bands (fiUp, fiDown)
            let fiUp = [];
            let fiDown = [];
            let prevFiUp = 0;
            let prevFiDown = 0;
            for (let i = 0; i < data.length; i++) {
                if (isNaN(baseUp[i])) {
                    fiUp.push(NaN);
                } else if (i === 0) {
                    fiUp.push(baseUp[i]);
                    prevFiUp = baseUp[i];
                } else {
                    fiUp.push(baseUp[i] < prevFiUp || data[i - 1].close > prevFiUp ? baseUp[i] : prevFiUp);
                    prevFiUp = fiUp[i];
                }

                if (isNaN(baseDown[i])) {
                    fiDown.push(NaN);
                } else if (i === 0) {
                    fiDown.push(baseDown[i]);
                    prevFiDown = baseDown[i];
                } else {
                    fiDown.push(baseDown[i] > prevFiDown || data[i - 1].close < prevFiDown ? baseDown[i] : prevFiDown);
                    prevFiDown = fiDown[i];
                }
            }

            // Step 5: Calculate Supertrend
            let st = [];
            let prevSt = NaN;

            for (let i = 0; i < data.length; i++) {
                if (i < period) {
                    st.push(NaN);
                    continue;
                }

                let nowSt = 0;

                // If previous supertrend is not set
                if (isNaN(prevSt)) {
                    nowSt = data[i].close <= fiUp[i] ? fiUp[i] : fiDown[i];
                } else if (prevSt === fiUp[i - 1] && data[i].close <= fiUp[i]) {
                    nowSt = fiUp[i]; // Continue uptrend if close is below fiUp
                } else if (prevSt === fiUp[i - 1] && data[i].close > fiUp[i]) {
                    nowSt = fiDown[i]; // Switch to downtrend if close is above fiUp
                } else if (prevSt === fiDown[i - 1] && data[i].close >= fiDown[i]) {
                    nowSt = fiDown[i]; // Continue downtrend if close is above fiDown
                } else if (prevSt === fiDown[i - 1] && data[i].close < fiDown[i]) {
                    nowSt = fiUp[i]; // Switch to uptrend if close is below fiDown
                }

                st.push(nowSt);
                prevSt = nowSt;
            }


            // Step 6: Final Output and Alignment Check
            let up = [];
            let down = [];
            let indexUp = [];
            let indexDown = [];
            for (let i = 0; i < data.length; i++) {
                if (isNaN(st[i])) {
                    up.push(st[i]);
                    down.push(st[i]);
                    continue; // Skip further logic for NaN st[i]
                }

                if (data[i].close < st[i]) {
                    // Downtrend
                    down.push(st[i]);
                    up.push(NaN);
                    indexDown.push(i);
                } else {
                    // Uptrend
                    down.push(NaN);
                    up.push(st[i]);
                    indexUp.push(i);
                }

                console.log(`i=${i}, Close=${data[i].close}, fiUp=${fiUp[i]}, fiDown=${fiDown[i]}, st=${st[i]}, up=${up[i]}, down=${down[i]}`);
            }

            console.log(data.length, atr.length, baseUp.length, fiUp.length, st.length);


            // console.log(up);
            // console.log(down);
            // // Step 3: Calculate Supertrend
            // let supertrend = [];
            // let colors = [];
            // supertrend.push(upperBand[0]); // The first supertrend is the first upper band value
            // colors.push('green');
            // // console.log(supertrend);
            // for (let i = 1; i < data.length; i++) {
            //     const currentClose = data[i].close;
            //     const previousSupertrend = supertrend[i - 1];

            //     if (currentClose > previousSupertrend) {
            //         // If the close is above the previous Supertrend, set to upper band
            //         supertrend.push(Math.max(upperBand[i], previousSupertrend));
            //         colors.push('green');  // Bullish, use green
            //     } else {
            //         // If the close is below the previous Supertrend, set to lower band
            //         supertrend.push(Math.min(lowerBand[i], previousSupertrend));
            //         colors.push('red');  // Bearish, use red
            //     }
            // }

            // supertrendSeries = chart.addLineSeries({
            //     color: 'red', // Default color (it will be updated dynamically)
            //     lineWidth: 2
            // });
            
            // const supertrendData = supertrend.map((st, index) => {
            //     return {
            //         time: data[index].time,  // Human-readable date
            //         value: st                      // Supertrend value
            //     };
            // });
            // console.log(supertrendData);
            // supertrendSeries.setData(supertrendData);

            let isUptrend = null;
            let currentSegment = [];
            const supertrendSegments = [];

            // Loop through your data to build trend segments
            for (let i = 0; i < data.length; i++) {
                const time = data[i].time;
                const upValue = up[i];
                const downValue = down[i];

                if (!isNaN(upValue)) {
                    if (isUptrend !== true) {
                        if (currentSegment.length) {
                            supertrendSegments.push({
                                data: currentSegment,
                                color: isUptrend === false ? 'red' : 'gray'
                            });
                        }
                        currentSegment = [];
                        isUptrend = true;
                    }
                    currentSegment.push({ time: time, value: upValue });
                } else if (!isNaN(downValue)) {
                    if (isUptrend !== false) {
                        if (currentSegment.length) {
                            supertrendSegments.push({
                                data: currentSegment,
                                color: isUptrend === true ? 'green' : 'gray'
                            });
                        }
                        currentSegment = [];
                        isUptrend = false;
                    }
                    currentSegment.push({ time: time, value: downValue });
                } else {
                    // Break line if no valid value
                    if (currentSegment.length) {
                        supertrendSegments.push({
                            data: currentSegment,
                            color: isUptrend ? 'green' : 'red'
                        });
                        currentSegment = [];
                    }
                    isUptrend = null;
                }
            }

            // Push any remaining segment
            if (currentSegment.length) {
                supertrendSegments.push({
                    data: currentSegment,
                    color: isUptrend ? 'green' : 'red'
                });
            }

            // Now create line series for each segment
            // supertrendSegments.forEach(segment => {
            //     let lineSeries = chart.addLineSeries({
            //         color: segment.color,
            //         lineWidth: 2,
            //         priceLineVisible: false,
            //         lastValueVisible: false
            //     });
            //     lineSeries.setData(segment.data);
            // });

            return supertrendSegments;


        }
 
        // HERE is to create SMA checkboxes
        function createSMACheckboxes(chartData) {
            const smaContainer = document.getElementById("sma-options");
            smaContainer.innerHTML = ""; // Clear existing checkboxes

            const smaPeriods = [20, 50, 100, 200, 365]; // Common SMA periods

            const details = document.createElement("details");
            const summary = document.createElement("summary");
            summary.innerText = "SMA Periods";
            details.appendChild(summary);

            const checkboxContainer = document.createElement("div");
            checkboxContainer.style.display = "flex";
            checkboxContainer.style.flexDirection = "column";
            checkboxContainer.style.padding = "8px";

            smaPeriods.forEach(period => {
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.id = `sma-${period}`;
                checkbox.value = period;
                //HERE is to call the function to draw lines
                checkbox.addEventListener("change", function () {
                    toggleSMA(period, this.checked, chartData);
                });

                const label = document.createElement("label");
                label.htmlFor = `sma-${period}`;
                label.innerText = `SMA ${period}`;

                const div = document.createElement("div");
                div.style.display = "flex";
                div.style.alignItems = "center";
                div.style.gap = "5px";

                div.appendChild(checkbox);
                div.appendChild(label);
                checkboxContainer.appendChild(div);
            });

            details.appendChild(checkboxContainer);
            smaContainer.appendChild(details);
        }

        // HERE is to calculate SMA with different periods
        function calculateSMA(data, period) {
            let smaData = [];
            for (let i = period - 1; i < data.length; i++) { 
                let sum = 0;
                for (let j = 0; j < period; j++) { 
                    sum += data[i - j].close;
                }
                let avg = sum / period;
                smaData.push({ time: data[i].time, value: avg });
            }
            // console.log("period", period); //81 sma (100-19)
            return smaData;
        }

        // HERE is to draw SMA lines
        function toggleSMA(period, checked, chartData) {
            //different shades of blue for different periods
            const smaColors = {
                20: '#1e95e3',  
                50: '#227bb5',  
                100: '#22648f', 
                200: '#1c4763',
                365: '#102b3d'  
            };
            const color = smaColors[period];
            if (checked) {
                if (!smaLines[period]) {
                    // console.log(smaLines[period]);
                    
                    smaLines[period] = chart.addLineSeries({
                        color: color, 
                        lineWidth: 2, 
                        lineStyle: 0 // Solid Line
                    });
                }
                //HERE is to call the function for calculation
                const smaData = calculateSMA(chartData, period);
                
                if (period == 50) {
                    // console.log(smaData);
                    sma50 = smaData;                    
                } else if (period == 200) {
                    // console.log(smaData);
                    sma200 = smaData;
                    
                    // console.log(sma200);
                } else if(period == 365){
                    sma365 = smaData;
                    if(mvrvSeries)
                        detectMVRVandSMA();
                }
                if(sma50 && sma200){
                    commentaries = detectCross(sma50, sma200);
                }else{

                    commentaries = null;
                }
                // console.log(sma50);
                // console.log(sma200);
                smaLines[period].setData(smaData);
            } else {
                if(period == 50){
                    sma50 = [];
                }
                if(period == 200){
                    sma200 = [];
                    // signals = [];
                }
                if(period == 365){
                    sma365 = [];
                    signals = [];
                }
                if(sma50 && sma200){
                    commentaries = detectCross(sma50, sma200);
                }else{
                    commentaries = null;
                }
                if (smaLines[period]) {
                    chart.removeSeries(smaLines[period]);
                    delete smaLines[period];
                    // commentaries = null;
                }
                
            }

            // const remainingSMAs = Object.keys(smaLines);
            // if (remainingSMAs.length > 0) {
            //     updateLegend("SMA", 0, color);
            // } else {
            //     updateLegend("SMA", "None", color);
            // }
        }

        function detectCross(smaShort, smaLong){
            let commentaries = [];
            // console.log("Im here");
            for (let i = 1; i < smaShort.length; i++) {
                const shortPoint = smaShort[i];
                const prevShortPoint = smaShort[i - 1];
                const longIndex = smaLong.findIndex(p => p.time === shortPoint.time);
                const prevLongIndex = smaLong.findIndex(p => p.time === prevShortPoint.time);

                if (longIndex > 0 && prevLongIndex > 0) {
                    const prevShort = prevShortPoint.value;
                    const prevLong = smaLong[prevLongIndex].value;
                    const currShort = shortPoint.value;
                    const currLong = smaLong[longIndex].value;
                    // Golden Cross
                    if (prevShort < prevLong && currShort >= currLong) {
                        commentaries.push({
                            time: smaShort[i].time,
                            type: "golden",
                            text: "Golden Cross detected: Bullish momentum likely."
                        });
                    }

                    // Death Cross
                    if (prevShort > prevLong && currShort <= currLong) {
                        commentaries.push({
                            time: smaShort[i].time,
                            type: "death",
                            text: "Death Cross detected: Bearish trend may follow."
                        });
                    }
                }
            }

            return commentaries;
        }

        // HERE is to calculate EMA with different periods
        function calculateEMA(data, period) {
            let emaData = [];
            let multiplier = 2 / (period + 1); // Smoothing factor 2/21

            // Start with the first SMA as the initial EMA value
            let sum = 0;
            for (let i = 0; i < period; i++) {// i<50
                sum += data[i].close;
            }
            let prevEMA = sum / period;
            if (data[period - 1]) {
                // console.log("Im here");
                emaData.push({ time: data[period - 1].time, value: prevEMA });
            }

            // Calculate EMA for the rest
            for (let i = period; i < data.length; i++) {
                let ema = (data[i].close - prevEMA) * multiplier + prevEMA;
                emaData.push({ time: data[i].time, value: ema });
                prevEMA = ema;
            }
            return emaData;
        }

        // HERE is to calculate the BB with fixed(20) periods
        function calculateBollingerBands(data, period = 20, multiplier = 2) {
            let bands = [];
            for (let i = period - 1; i < data.length; i++) {
                let slice = data.slice(i - period + 1, i + 1); // Get last `period` values
                let sma = slice.reduce((sum, d) => sum + d.close, 0) / period;

                // Calculate standard deviation
                let variance = slice.reduce((sum, d) => sum + Math.pow(d.close - sma, 2), 0) / period;
                let stdDev = Math.sqrt(variance);

                let upperBand = sma + (stdDev * multiplier);
                let lowerBand = sma - (stdDev * multiplier);

                bands.push({ time: data[i].time, middle: sma, upper: upperBand, lower: lowerBand });

                // Check if BTC price crosses or touches the lower band
                if (data[i].close <= lowerBand) {
                    bbAlerts.push({ time: data[i].time, price: data[i].close, message: `Price ($${data[i].close}) touched or crossed the lower Bollinger Band!` });
                }
            }
            return bands;
        }

        // HERE is to remove the BB (3 series) when the checkbox is unchecked or when the chart is reset/switched
        function removeBollingerBands() {
            if (bollingerUpperSeries) {
                chart.removeSeries(bollingerUpperSeries);
                bollingerUpperSeries = null;
            }
            if (bollingerLowerSeries) {
                chart.removeSeries(bollingerLowerSeries);
                bollingerLowerSeries = null;
            }
            if (bollingerMiddleSeries) {
                chart.removeSeries(bollingerMiddleSeries);
                bollingerMiddleSeries = null;
            }
            bbAlerts = [];
        }

        //2nd HERE is to calculate the Fibonacci level with 7 level 
        function calculateFibonacciLevels(high, low) {
            return {
                0.0: high - (0.0 * (high - low)),
                0.236: high - (0.236 * (high - low)),
                0.382: high - (0.382 * (high - low)),
                0.5: high - (0.5 * (high - low)),
                0.618: high - (0.618 * (high - low)),
                0.786: high - (0.786 * (high - low)),
                1.0: high - (1.0 * (high - low)),
            };
        }

        //3rd HERE is to draw the Fibonacci lines when checkbox is checked
        //horizontal priceLine is used
        function drawFibonacci(level, value, checked) {
            if (checked) {
                if (!fibonacciLines[level]) {
                    fibonacciLines[level] = candleSeries.createPriceLine({
                        price: value,
                        color: '#edb90e', 
                        lineWidth: 1,
                        lineStyle: 2, // Dashed Line
                        axisLabelVisible: true, // Show label on the price axis
                        title: `Fib ${level}%` // Label for the Fibonacci level
                    });
                }
            } else {
                if (fibonacciLines[level]) {
                    candleSeries.removePriceLine(fibonacciLines[level]);
                    delete fibonacciLines[level];
                }
            }

            // Update legend based on remaining Fibonacci levels
            // const remainingLevels = Object.keys(fibonacciLines);
            // if (remainingLevels.length > 0) {
            //     updateLegend("fib", 0, "#edb90e");
            // } else {
            //     updateLegend("fib", "None", "#73c769");
            // }
        }

        //1st HERE is to create Fibonacci checkbox dynamically
        function createFibonacciCheckboxes(chartData) {
            const fibContainer = document.getElementById("fibonacci-options");
            fibContainer.innerHTML = ""; // Clear existing checkboxes

            const high = Math.max(...chartData.map(d => d.high));
            const low = Math.min(...chartData.map(d => d.low));
            //HERE is to call the function for calculation
            const fibLevels = calculateFibonacciLevels(high, low);

            // Create dropdown container
            const details = document.createElement("details");
            const summary = document.createElement("summary");
            summary.innerText = "Fibonacci Levels";
            
            details.appendChild(summary);

            const checkboxContainer = document.createElement("div");
            checkboxContainer.style.display = "flex";
            checkboxContainer.style.flexDirection = "column";
            checkboxContainer.style.padding = "8px";

            Object.entries(fibLevels)
            .sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]))
            .forEach(([level, value]) => {
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.id = `fib-${level}`;
                checkbox.value = level;
                //HERE is to call the function for drawing the lines
                checkbox.addEventListener("change", function () {
                    drawFibonacci(level, value, this.checked, chartData);
                });

                const label = document.createElement("label");
                label.htmlFor = `fib-${level}`;
                label.innerText = `Fib ${level}`;

                const div = document.createElement("div");
                div.style.display = "flex";
                div.style.alignItems = "center";
                div.style.gap = "5px";

                div.appendChild(checkbox);
                div.appendChild(label);
                checkboxContainer.appendChild(div);
            });

            details.appendChild(checkboxContainer);
            fibContainer.appendChild(details);
        }

        //HERE is to calculate RSI
        function calculateRSI(data, period = 14) {
            let gains = [];
            let losses = [];
            // Step 1: Compute gains & losses
            for (let i = 1; i < data.length; i++) {
                let change = data[i].close - data[i - 1].close;
                gains.push(change > 0 ? change : 0);
                losses.push(change < 0 ? Math.abs(change) : 0);
            }

            // Step 2: Compute initial average gain/loss
            let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
            let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;

            let rsi = [];

            // Step 3: Compute RSI for each period
            for (let i = period; i < gains.length; i++) {
                avgGain = (avgGain * (period - 1) + gains[i]) / period;
                avgLoss = (avgLoss * (period - 1) + losses[i]) / period;

                let rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                let rsiValue = 100 - (100 / (1 + rs));

                rsi.push({ time: data[i + 1].time, value: rsiValue });
            }

            return rsi;
        }

        function findPivots(data, isHigh = true, lookback = 3) {
            const pivots = [];
            for (let i = lookback; i < data.length - lookback; i++) { // if data = 20, i = 3 to 16
                let isPivot = true;
                for (let j = 1; j <= lookback; j++) { // j = 1, 2, 3
                    if (
                        (isHigh && data[i].value <= data[i - j].value) || // data[3] <= data[0 to 2]
                        (isHigh && data[i].value <= data[i + j].value) || // data[3] <= data[4 to 6]
                        (!isHigh && data[i].value >= data[i - j].value) || // data[3] >= data[0 to 2]
                        (!isHigh && data[i].value >= data[i + j].value) // data[3] = data[4 to 6]
                    ) {
                        isPivot = false;
                        break;
                    }else{
                        // console.log(data[i].value);
                    }
                }
                if (isPivot) {
                    pivots.push({ index: i, value: data[i].value, time: data[i].time });
                    // console.log(pivots);
                }
            }
            // console.log(pivots);
            return pivots;
        }

        function detectDivergence(pricePivots, rsiPivots, isBullish = true) {
            const divergences = [];

            for (let i = 1; i < pricePivots.length; i++) {
                const priceCurrent = pricePivots[i];
                const pricePrev = pricePivots[i - 1];

                const rsiCurrent = rsiPivots.find(r => r.time === priceCurrent.time);
                const rsiPrev = rsiPivots.find(r => r.time === pricePrev.time);
                // console.log(priceCurrent, pricePrev);
                // console.log(rsiCurrent, rsiPrev);
                if (rsiCurrent && rsiPrev) {
                    if (
                        isBullish &&
                        priceCurrent.value < pricePrev.value &&      // lower low in price
                        rsiCurrent.value > rsiPrev.value             // higher low in RSI
                    ) {
                        divergences.push({ time: priceCurrent.time, type: 'bullish' });
                    }

                    if (
                        !isBullish &&
                        priceCurrent.value > pricePrev.value &&      // higher high in price
                        rsiCurrent.value < rsiPrev.value             // lower high in RSI
                    ) {
                        divergences.push({ time: priceCurrent.time, type: 'bearish' });
                    }
                }
            }

            return divergences;
        }

        // ** Extra features : markers and borders ** //

        function clearAllIndicators() {
            const bbCheckbox = document.getElementById('bb-select');
            const rsiCheckbox = document.getElementById('rsi-checkbox');
            const sentCheckbox = document.getElementById('sent-checkbox');
            let smaSelect = document.getElementById('sma-select');
            let emaSelect = document.getElementById('ema-select');
            let analysisSelect = document.getElementById('analysis-select');
            let superSelect = document.getElementById('super-checkbox');
            // 1. remove EMA lines everytime the chart is switched
            emaSelect.value = ""; //clear the list for EMA
            if (emaSeries) { chart.removeSeries(emaSeries); emaSeries = null; }
               
            // 2. remove Fibonacci lines
            document.querySelectorAll('#fibonacci-options input[type="checkbox"]').forEach(
                cb => cb.checked = false);

            Object.values(fibonacciLines).forEach(series => {
                if(candleSeries){
                    candleSeries.removePriceLine(series);
                }
            });
            fibonacciLines = {}; 
                // console.log(candleSeries);
                //remove chart data
                
            // 3. remove SMA lines
            document.querySelectorAll('#sma-options input[type="checkbox"]').forEach(
                cb => cb.checked = false);

            Object.values(smaLines).forEach(series => {
                chart.removeSeries(series);
            });
            smaLines = {};
                // if (smaLines) { chart.removeSeries(smaLines); smaLines = null; }
                // console.log(Object.keys(smaLines).length === 0);
                // console.log(Object.keys(fibonacciLines).length === 0);
               
                // console.log(emaSeries == null);
            // 4. remove BB lines
            bbCheckbox.checked = false;
            removeBollingerBands();
            // 5. remove RSI
            rsiCheckbox.checked = false;
            if (rsiSeries) {
                rsiChart.removeSeries(rsiSeries);
                rsiSeries = null;
            }

            sentCheckbox.checked = false;
            if(sentimentSeries){
                removeSentimentLine();
            }
                // markers = [];

            // 6. remove ichimoku line and set checkbox to false
            document.querySelectorAll('#ichimoku-options input[type="checkbox"]').forEach(
                cb => cb.checked = false);

                
            Object.values(ichimokuLine).forEach(series => {
                chart.removeSeries(series);
            });
            ichimokuLine = {};

            // 7. remove mvrv lines
            if(mvrvSeries){
                chart.removeSeries(mvrvSeries);
                mvrvSeries = null;
            }

            // 8. clear tweetBox and newBox
            tweetBox.innerHTML = "";
            tweetData = [];
            newBox.innerHTML = "";
            tweetBox.style.display = "none";
            newBox.style.display = "none";


            // 9. clear m2
            analysisSelect.value = "";
            if(m2Series){
                chart.removeSeries(m2Series);
                m2Series = null;
            }

            // 10. clear supertrend series
            superSelect.checked = false;
            if (supertrendSeries && supertrendSeries.length) {
                supertrendSeries.forEach(series => {
                    chart.removeSeries(series);
                });
                supertrendSeries = [];          // Clear references to the series
            }

            supertrendSegments = [];            // Set to empty array, not null

            
        }


        function setMarkers(markerArray){
            markers = [...markers, ...markerArray];
            if(markers){
                // console.log(markers);
                candleSeries.setMarkers(markers);
            }
            markers.forEach(item => {
                // console.log(item.time);
            })

           
        }

        //HERE is to shorten the event title into suitable short label
        //now didn't use it
        function shortenEventLabel(title) {
            // Common financial and stock-related abbreviations
            const abbreviations = {
                "Federal Reserve": "Fed",
                "Interest Rate": "Rate",
                "Approval": "Approved",
                "Decision": "Dec.",
                "Announces": "",
                "Reports": "",
                "Earnings": "Earnings",
                "Bitcoin": "BTC",
                "Ethereum": "ETH",
                "Halving": "Halving",
                "Merger": "Merge",
                "Market Rally": "Rally",
                "Stock Crash": "Crash",
                "Inflation": "CPI"
            };

            // Split the title into words
            let words = title.split(" ");

            // Replace words with abbreviations where applicable
            let shortenedWords = words.map(word => abbreviations[word] || word);

            // Remove empty words and unnecessary conjunctions
            let filteredWords = shortenedWords.filter(word => word && !["the", "is", "on", "for", "to"].includes(word.toLowerCase()));

            // Join back into a shortened title
            return filteredWords.join(" ");
        }
        
        //HERE is to update the legend dynamically
        //now only for bollinger bands
        function updateLegend(indicator, period, color) {
           
            const legendContainer = document.getElementById("smaLegend"); // Use a general container for all legends
            // Check if the legend for this specific indicator already exists
            let existingLegend = document.getElementById(`legend-${indicator}`);
            let leg = document.getElementById(`${indicator}-select`);
            // console.log("line 101", leg);
            // console.log("line 102", indicator);
            let selectedText = null;
            if(indicator=="bb"){
                // console.log("bb");
                selectedText = leg.innerText;}
            // else if (indicator == "fib") {
            //     // console.log("fib");
            //     selectedText = getFibonacciLevel();
            //     // console.log(selectedText);
            // }else if (indicator == "SMA"){
            //     selectedText = getSMAPeriod();
            //     // console.log("SMA");
            // }
            // else{ //for ema and sma (single option)
            //     // console.log("Im else");
            //     selectedText = leg.options[leg.selectedIndex].innerText;
            //     // console.log("EMA");
            // }
            // console.log("line 108", selectedText);
           
            // if period == "None"
            if(isNaN(period)){
                if(existingLegend){
                    legendContainer.removeChild(existingLegend);
                }
                return;
            }
            if (existingLegend) {
                // Remove the existing legend for the same indicator before adding a new one
                legendContainer.removeChild(existingLegend);
            }
            //if 0 go here
            // Create a new legend item if it doesn‚Äôt exist
            const legendItem = document.createElement("div");
            legendItem.id = `legend-${indicator}`;  // Unique ID for each legend
            legendItem.style.color = color;
            legendItem.style.fontSize = "14px";
            legendItem.style.fontWeight = "bold";
            if(indicator!="bb")
                legendItem.innerText = selectedText;
            else
                legendItem.innerText = "Bollinger Bands";
            // console.log("line 119",legendItem.id)
            // Append new legend item
            
            legendContainer.appendChild(legendItem);
            
            updateLegendBorder();
            
        }

        //HERE is to update the legend border dynamically
        function updateLegendBorder() {
            const legendContainer = document.getElementById("smaLegend");

            if (legendContainer.childElementCount === 0) {
                // If empty, no border
                legendContainer.style.border = "0px";
            } 
            else {
                // If has items, use solid border
                legendContainer.style.border = "2px solid #b3bab3";
            }
            
        }
        
        // compare the date of the tweet with the chart date
        function isSameDate(date1, date2) {
            // Ensure both date1 and date2 are in milliseconds
            const d1 = new Date(date1 * 1000);  // Convert to milliseconds if it's in seconds
            const d2 = new Date(date2 * 1000);  // Convert to milliseconds if it's in seconds
            // console.log(d1,d2);
            // Normalize to date-only (set time to 00:00:00.000)
            d1.setHours(0, 0, 0, 0);
            d2.setHours(0, 0, 0, 0);
            // console.log(d1,d2);
            // Compare the dates
            return d1.getTime() === d2.getTime();
        }

        async function loadChart(timeframe) {
            const binanceTimeframe = timeframe;
            document.getElementById("smaLegend").innerHTML = "";
            updateLegendBorder();
            time = timeframe;
            
            //clear chartData if there is any to ensure it contains the latest data
            chartData = [];
            // if using binanceAPI
            chartData = await fetchData(binanceTimeframe);
            // lineData = await fetchLineData(binanceTimeframe);
            // if using alphaVantage
            // chartData = await fetchData();
            // console.log("line 761", chartData);
            const bbCheckbox = document.getElementById('bb-select');
            const rsiCheckbox = document.getElementById('rsi-checkbox');
            const sentCheckbox = document.getElementById('sent-checkbox');
            let smaSelect = document.getElementById('sma-select');
            let emaSelect = document.getElementById('ema-select');
            let analysisSelect = document.getElementById('analysis-select');
            let superSelect = document.getElementById('super-checkbox');
            // console.log("Current timeframe:", timeframe);
    
            if (candleSeries!=null) {
                // console.log("Im not null");
                chart.removeSeries(candleSeries);
                // console.log(candleSeries);
                candleSeries = null;
            }
            
            if (chartData) {
                const latestCandle = chartData[chartData.length - 1];
                console.log("Loading chart for:", timeframe);
                // smaSelect.value = "";
                // Remove all the old series before adding a new one
                
                markers = [];

                clearAllIndicators();
                // toggleSentimentLine();  // This will either add or remove the line based on checkbox state
                // if(supertrendSeries){
                //     console.log("Im stseries");
                //     chart.removeSeries(supertrendSeries); 
                //     supertrendSeries = null;
                // }

                //if (rsiSeries) { chart.removeSeries(rsiSeries); rsiSeries = null; }
                
                // if (bollingerUpperSeries) chart.removeSeries(bollingerUpperSeries);
                // if (bollingerLowerSeries) { chart.removeSeries(bollingerLowerSeries); bollingerLowerSeries = null; }
                // if (bollingerMiddleSeries) { chart.removeSeries(bollingerMiddleSeries); bollingerMiddleSeries = null; }

                //HERE is to set the bitcoin data
                candleSeries = chart.addCandlestickSeries();
                candleSeries.setData(chartData);
                if(candleSeries!=null) {
                    // console.log(chartData);
                }
                // console.log(binanceTimeframe);
                // console.log(timeframe);
                
                //lineSeries.setData(lineData);
                //HERE is to fetch the federal fund rate then fetch the corresponding events (now didn't use)
                //then label the event in daily chart (but now just filter based on the keywords)
                fetchNew(chartData);
                // fetchMacroData();
                // await fetchMVRV();
                // setEvent(candleSeries);
                //HERE is to create fibonacci checkboxes then plot the lines
                createFibonacciCheckboxes(chartData);
                //HERE is to create SMA checkboxes then plot the lines
                createSMACheckboxes(chartData);
                // detectMVRVandSMA();
                createIchimokuCheckboxes(chartData);
                fetchTwitter();
                // const result = calculateIchimoku(chartData);
                // console.log(result);
                // Listen for changes in the checkbox to toggle sentiment line
                const sentimentCheckbox = document.getElementById('sent-checkbox');
                // sentimentCheckbox.addEventListener('change', toggleSentimentLine);
                // create a separate chart for RSI
                if (!rsiChart) {
                    rsiChart = LightweightCharts.createChart(document.getElementById('rsi-container'), {
                        width: document.getElementById('rsi-container').clientWidth,
                        height: 200,
                        layout: { backgroundColor: '#ffffff', textColor: '#000' },
                        grid: { vertLines: { color: '#eeeeee' }, horzLines: { color: '#eeeeee' } }
                    });
                }

                
                // fetchMacroData();
                emaSelect.addEventListener('change', function () {
                    if (emaSeries) chart.removeSeries(emaSeries);  // Remove old EMA before adding new one
                    const selectedPeriod = parseInt(this.value);
                    // console.log("Ema period", selectedPeriod);
                    // if (!selectedPeriod) return;  // If "None" is selected, do nothing
                    // updateLegend("ema", selectedPeriod, "#73c769"); 
                    
                    const emaData = calculateEMA(chartData, selectedPeriod);
                    emaSeries = chart.addLineSeries({ color: '#f58747', lineWidth: 2 });
                    emaSeries.setData(emaData);
                    //updateLegend("ema", selectedPeriod, "#73c769"); 
                });
                // add event listener for bb
                bbCheckbox.addEventListener('change', function () {
                    if (this.checked) {
                        const bollingerData = calculateBollingerBands(chartData, 20, 2);
                        if (!bollingerUpperSeries){
                            // Middle Band (SMA)
                            bollingerMiddleSeries = chart.addLineSeries({ color: '#7242a6', lineWidth: 2 , lineStyle: 2});
                            bollingerMiddleSeries.setData(bollingerData.map(d => ({ time: d.time, value: d.middle })));

                            // Upper Band
                            bollingerUpperSeries = chart.addLineSeries({ color: '#c474fc', lineWidth: 2 });
                            bollingerUpperSeries.setData(bollingerData.map(d => ({ time: d.time, value: d.upper })));

                            // Lower Band
                            bollingerLowerSeries = chart.addLineSeries({ color: '#c474fc', lineWidth: 2 });
                            bollingerLowerSeries.setData(bollingerData.map(d => ({ time: d.time, value: d.lower })));

                            updateLegend("bb", 0, "#8c50cc"); 
                        }
                    } 
                    else {
                        removeBollingerBands();
                        updateLegend("bb", "None", "#8c50cc"); 
                    }
                });

                analysisSelect.addEventListener('change', async function () {
                    if (m2Series) {
                        chart.removeSeries(m2Series);
                        m2Series = null;
                    }
                    if (mvrvSeries) {
                        chart.removeSeries(mvrvSeries);  
                        mvrvSeries = null;
                    }
                    
                    // console.log("Ema period", selectedPeriod);
                    if (!this.value) return;  // If "None" is selected, do nothing
                    switch (this.value) {
                        case "m2":
                            await fetchM2();
                            break;
                        case "mvrv":
                            await fetchMVRV();
                            break;
                        default:
                            // Optionally handle unknown values
                            console.warn("Unknown metric selected:", this.value);
                            break;
                    }
                });

                superSelect.addEventListener('change',handleSupertrendToggle);
                // add event listener for rsi
                rsiCheckbox.addEventListener('change', function () {
                    if (!rsiChart) return;
                    if (this.checked) {
                        if (rsiSeries) {
                            rsiChart.removeSeries(rsiSeries); // Remove previous RSI series
                        }
                        const rsiData = calculateRSI(chartData, 14);

                        rsiSeries = rsiChart.addLineSeries({
                            color: '#9467bd',
                            lineWidth: 2,
                        });

                        rsiSeries.setData(rsiData);
                        if (!rsiDashedLines) {
                            rsiDashedLines = [
                                rsiChart.addLineSeries({
                                    color: '#00FF00', 
                                    lineWidth: 1,
                                    lineStyle: 2, // Dashed line
                                }),
                                rsiChart.addLineSeries({
                                    color: '#00FF00', 
                                    lineWidth: 1,
                                    lineStyle: 2, //
                                }),
                            ];

                            const minTime = rsiData[0].time;
                            const maxTime = rsiData[rsiData.length - 1].time;

                            rsiDashedLines[0].setData([{ time: minTime, value: 70 }, { time: maxTime, value: 70 }]);
                            rsiDashedLines[1].setData([{ time: minTime, value: 30 }, { time: maxTime, value: 30 }]);
                        }
                        const closePrices = chartData.map(d => ({
                            time: d.time,
                            value: d.close
                        }));

                        const priceLows = findPivots(closePrices, false);
                        const rsiLows = findPivots(rsiData, false);

                        const priceHighs = findPivots(closePrices, true);
                        const rsiHighs = findPivots(rsiData, true);

                        

                        const bullishDivs = detectDivergence(priceLows, rsiLows, true);
                        const bearishDivs = detectDivergence(priceHighs, rsiHighs, false);

                        const allDivergences = [...bullishDivs, ...bearishDivs];

                        // console.log(bullishDivs);

                        const bullishMarkers = allDivergences.map(div => ({
                            time: div.time,
                            position: 'belowBar',
                            color: div.type === 'bullish' ? 'green' : 'red',
                            shape: 'arrowUp',
                            text: div.type === 'bullish' ? 'Bullish sign' : 'Bearish sign'
                        }));
                        rsiSeries.setMarkers(bullishMarkers);
                        console.log(bullishMarkers);
                        // const bearishMarkers = bearishDivs.map(div => ({
                        //     time: div.time,
                        //     position: 'belowBar',
                        //     color: 'red',
                        //     shape: 'arrowDown',
                        //     text: 'Bearish sign'
                        // }));

                        // const allMarkers = bullishMarkers.concat(bearishMarkers); // instead of spread
                        // rsiSeries.setMarkers(bullishMarkers);   

                        // rsiSeries.setMarkers(bearishMarkers);
                        // rsiSeries.setMarkers(bullishMarkers);
                    } else {
                        if (rsiSeries) { 
                            rsiChart.removeSeries(rsiSeries); rsiSeries = null; 
                        }
                    }
                    
                });
                // m2Data = 
                // m2Series.setData(m2Data);
                document.title = `BTC ${timeframe.toUpperCase()} - $${latestCandle.close.toFixed(2)}`;
                let timeC = "Daily (1D)";
                if(timeframe === '1d') {
                    timeC = "Daily (1D)";
                } else if (timeframe === '4h') {
                    timeC = "4-Hour (4h)";
                } else if (timeframe === '1w') {
                    timeC = "Weekly (1w)";
                }
                document.getElementById("chart-label").innerText = `Current Chart: ${timeC}`;
                         
            }
        }

        let currentTweetTime = null;

        window.onload = async function() {
            // console.log(LightweightCharts);
            if (typeof LightweightCharts === "undefined") {
                console.error("üö® LightweightCharts is NOT loaded! Check your script tag.");
                return;
            }
            
            const chartContainer = document.getElementById('chart-container');
            if (!chartContainer) {
                console.error("Chart container not found!");
                return;
            }
            chart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth,
                height: 600,
                layout: { backgroundColor: '#ffffff', textColor: '#000' },
                grid: { vertLines: { color: '#eeeeee' }, horzLines: { color: '#eeeeee' } },
                rightPriceScale: { visible: true, borderColor: '#d1d4dc' }, // BTC on right axis
                leftPriceScale: { visible: true, borderColor: '#d1d4dc' }   // M2 on left axis
            });
            // window.addEventListener('resize', ()=>{
            //     const width = chartContainer.clientWidth;
            //     const height = chartContainer.clientHeight;
            //     chart.resize(width, height);
            // })
            // Add BTC Candlestick Series (Right Axis)
            candleSeries = chart.addCandlestickSeries({ priceScaleId: 'right' });

            

            

            lineSeries = chart.addLineSeries({
                color: 'blue', // Set the color for the line
                lineWidth: 2,  // Adjust line thickness
                zIndex : 2000
            });

            

            baseSentimentSeries = chart.addHistogramSeries({
                priceScaleId: 'left',
                lineWidth: 2
            });

            topSentimentSeries = chart.addHistogramSeries({
                priceScaleId: 'left',
                lineWidth: 2
            });

            await loadChart('1d'); // Load default chart
            // await fetchM2();
            // await fetchMaxSentData('1d');

            // Create the tooltip div
            const tooltip = document.createElement("div");
            tooltip.style.position = "absolute";
            tooltip.style.background = "white";
            tooltip.style.padding = "5px";
            tooltip.style.borderRadius = "5px";
            tooltip.style.border = "1px solid #ccc";
            tooltip.style.fontSize = "14px";
            tooltip.style.display = "none";
            tooltip.style.pointerEvents = "none"; // Prevents tooltip from interfering with mouse events
            tooltip.style.zIndex = "1000"; // Ensures tooltip appears above everything
            document.body.appendChild(tooltip);
            const smaColors = {
                20: '#1e95e3',  
                50: '#227bb5',  
                100: '#22648f', 
                200: '#1c4763',
                365: '#102b3d'
            };

            const ichiColors = {
                "Tenkansen": '#71c752',  
                "Kijunsen": '#2f4a25',  
                "Senkou Span A": '#339660', 
                "Senkou Span B": '#0ce8aa', 
                "Chikou Span": '#149ea6'
            };

            


            // Function to handle tooltip on hover
            chart.subscribeCrosshairMove(param => {
                if (!param || !param.point || !param.seriesData || !param.time) {
                    tooltip.style.display = "none";
                    tweetBox.style.display = "none";
                    return;
                }

                const { point, seriesData } = param;
                let text = "";

                // Loop through SMA lines and check if they have data at the hovered point
                Object.keys(smaLines).forEach(period => {
                    if (seriesData.has(smaLines[period])) {
                        const value = seriesData.get(smaLines[period]).value;
                        text += `<b style="color: ${smaColors[period]};">SMA ${period}:</b> ${value.toFixed(2)}<br>`;
                    }
                });

                Object.keys(fibonacciLines).forEach(level => {
                    if (seriesData.has(fibonacciLines[level])) {
                        const value = seriesData.get(fibonacciLines[level]).value;
                        text += `<b>Fibonacci ${level}:</b> ${value.toFixed(2)}<br>`;
                    }
                });

                Object.keys(ichimokuLine).forEach(period => {
                    if (seriesData.has(ichimokuLine[period])) {
                        const value = seriesData.get(ichimokuLine[period]).value;
                        const color = ichiColors[period];
                        text += `
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <span style="
                                    width: 40px;
                                    height: 4px;
                                    // background-color: ${color};
                                    border-top: 2px ${period === 'Senkou Span A' || period === 'Senkou Span B' ? 'solid' : 'dashed'} ${color};
                                "></span>
                                <b style="color: ${color};">${period}:</b> ${value.toFixed(2)}
                            </div>
                        `;
                    }
                });

                const ema = document.getElementById("ema-select").value;
                if (ema && emaSeries) {  // Check if EMA is selected and exists
                    if (seriesData.has(emaSeries)) {
                        const value = seriesData.get(emaSeries).value;
                        const color = "#f58747";
                        text += `<b style="color: ${color};">EMA ${ema}:</b> ${value.toFixed(2)}<br>`;
                    }
                }

                if(mvrvSeries){
                    
                    if (seriesData.has(mvrvSeries)) {
                        const value = seriesData.get(mvrvSeries).value;
                        const color = "#d99696";
                        text += `
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <span style="
                                width: 40px;
                                height: 4px;
                                border-top: 2px solid ${color};
                            "></span>
                            <b style="color: ${color};">MVRV:</b> ${value.toFixed(2)}<br>
                        </div>
                        `;
                    }

                    // if(signals){
                    //     const hoveredUnix = param.time; // e.g. 1745539200
                    //     const hoveredDate = new Date(hoveredUnix * 1000).toISOString().slice(0, 10); // 'YYYY-MM-DD'
                    //     const signal = signals.find(item => item.date === hoveredDate);

                    //     if (signal) {
                    //         text += `<br><b style="color: #d99696;">üìù ${signal.signal}</b><br>`;
                    //     }
                    // }
                }

                if(m2Series){
                    
                    if (seriesData.has(m2Series)) {
                        const value = seriesData.get(m2Series).value;
                        const color = "#d19a02";
                        text += `
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <span style="
                                width: 40px;
                                height: 4px;
                                border-top: 2px solid ${color};
                            "></span>
                            <b style="color: ${color};">M2:</b> ${value.toFixed(2)}<br>
                        </div>
                        `;
                    }

            
                }

                if(supertrendSeries){
                    supertrendSeries.forEach(series => {
                        if (!param.seriesData.has(series)) return;
                        const value = param.seriesData.get(series);
                        if (value) {
                            text += `
                                <b style="color: ${series.options().color};">Supertrend:</b> ${value.value.toFixed(2)}<br>
                            `;
                        }
                    });
                } 

        

                // if (stepSeries) {  // Check if EMA is selected and exists
                //     if (seriesData.has(stepSeries)) {
                //         const value = seriesData.get(stepSeries).value;
                //         const color = "#b08d04";
                //         text += `<b style="color: ${color};">Positive/Negative (Sentiment) ${ema}:</b> ${value.toFixed(2)}<br>`;
                //     }
                // }

                // if (sentimentSeries) {  // Check if EMA is selected and exists
                //     if (seriesData.has(sentimentSeries)) {
                //         const value = seriesData.get(sentimentSeries).value;
                //         const color = "#f58747";
                //         text += `<b style="color: ${color};">Sentiment ${ema}:</b> ${value.toFixed(2)}<br>`;
                //     }
                // }
                if(commentaries){
                    const hoveredTime = param.time;
                    const commentary = commentaries.find(item => item.time === hoveredTime);

                    if (commentary) {
                        const color = commentary.type === "golden" ? "#a19528" : "#cc0000";
                        text += `<b style="color: ${color};">üìù ${commentary.text}</b><br>`;
                    }
                }

                

                if(bbAlerts){
                    const hoveredTime = param.time;
                    const alert = bbAlerts.find(item => item.time === hoveredTime);

                    if (alert) {
                        const color = alert.type === "golden" ? "#75e346" : "#cc0000";
                        text += `<b style="color: #ad3131;">${alert.message}</b><br>`;
                    }
                }

                if (!param.time) return;
                if (text !== "") {
                    tooltip.innerHTML = text;
                    tooltip.style.left = `${point.x + 10}px`;
                    tooltip.style.top = `${point.y - 10}px`;
                    tooltip.style.display = "block";
                } else {
                    tooltip.style.display = "none";
                }
            });
            let tweetBoxVisible = false;
            
            // click function to make tooltip occur
            


        };
    </script>
</body>
</html>
